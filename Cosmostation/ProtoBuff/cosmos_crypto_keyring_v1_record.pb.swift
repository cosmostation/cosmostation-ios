// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cosmos/crypto/keyring/v1/record.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Record is used for representing a key in the keyring.
struct Cosmos_Crypto_Keyring_V1_Record {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name represents a name of Record
  var name: String = String()

  /// pub_key represents a public key in any format
  var pubKey: Google_Protobuf_Any {
    get {return _pubKey ?? Google_Protobuf_Any()}
    set {_pubKey = newValue}
  }
  /// Returns true if `pubKey` has been explicitly set.
  var hasPubKey: Bool {return self._pubKey != nil}
  /// Clears the value of `pubKey`. Subsequent reads from it will return its default value.
  mutating func clearPubKey() {self._pubKey = nil}

  /// Record contains one of the following items
  var item: Cosmos_Crypto_Keyring_V1_Record.OneOf_Item? = nil

  /// local stores the public information about a locally stored key
  var local: Cosmos_Crypto_Keyring_V1_Record.Local {
    get {
      if case .local(let v)? = item {return v}
      return Cosmos_Crypto_Keyring_V1_Record.Local()
    }
    set {item = .local(newValue)}
  }

  /// ledger stores the public information about a Ledger key
  var ledger: Cosmos_Crypto_Keyring_V1_Record.Ledger {
    get {
      if case .ledger(let v)? = item {return v}
      return Cosmos_Crypto_Keyring_V1_Record.Ledger()
    }
    set {item = .ledger(newValue)}
  }

  /// Multi does not store any information.
  var multi: Cosmos_Crypto_Keyring_V1_Record.Multi {
    get {
      if case .multi(let v)? = item {return v}
      return Cosmos_Crypto_Keyring_V1_Record.Multi()
    }
    set {item = .multi(newValue)}
  }

  /// Offline does not store any information.
  var offline: Cosmos_Crypto_Keyring_V1_Record.Offline {
    get {
      if case .offline(let v)? = item {return v}
      return Cosmos_Crypto_Keyring_V1_Record.Offline()
    }
    set {item = .offline(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Record contains one of the following items
  enum OneOf_Item: Equatable {
    /// local stores the public information about a locally stored key
    case local(Cosmos_Crypto_Keyring_V1_Record.Local)
    /// ledger stores the public information about a Ledger key
    case ledger(Cosmos_Crypto_Keyring_V1_Record.Ledger)
    /// Multi does not store any information.
    case multi(Cosmos_Crypto_Keyring_V1_Record.Multi)
    /// Offline does not store any information.
    case offline(Cosmos_Crypto_Keyring_V1_Record.Offline)

  #if !swift(>=4.1)
    static func ==(lhs: Cosmos_Crypto_Keyring_V1_Record.OneOf_Item, rhs: Cosmos_Crypto_Keyring_V1_Record.OneOf_Item) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.local, .local): return {
        guard case .local(let l) = lhs, case .local(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ledger, .ledger): return {
        guard case .ledger(let l) = lhs, case .ledger(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multi, .multi): return {
        guard case .multi(let l) = lhs, case .multi(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.offline, .offline): return {
        guard case .offline(let l) = lhs, case .offline(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Item is a keyring item stored in a keyring backend.
  /// Local item
  struct Local {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var privKey: Google_Protobuf_Any {
      get {return _privKey ?? Google_Protobuf_Any()}
      set {_privKey = newValue}
    }
    /// Returns true if `privKey` has been explicitly set.
    var hasPrivKey: Bool {return self._privKey != nil}
    /// Clears the value of `privKey`. Subsequent reads from it will return its default value.
    mutating func clearPrivKey() {self._privKey = nil}

    var privKeyType: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _privKey: Google_Protobuf_Any? = nil
  }

  /// Ledger item
  struct Ledger {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var path: Cosmos_Crypto_Hd_V1_BIP44Params {
      get {return _path ?? Cosmos_Crypto_Hd_V1_BIP44Params()}
      set {_path = newValue}
    }
    /// Returns true if `path` has been explicitly set.
    var hasPath: Bool {return self._path != nil}
    /// Clears the value of `path`. Subsequent reads from it will return its default value.
    mutating func clearPath() {self._path = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _path: Cosmos_Crypto_Hd_V1_BIP44Params? = nil
  }

  /// Multi item
  struct Multi {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Offline item
  struct Offline {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _pubKey: Google_Protobuf_Any? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cosmos.crypto.keyring.v1"

extension Cosmos_Crypto_Keyring_V1_Record: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Record"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "pub_key"),
    3: .same(proto: "local"),
    4: .same(proto: "ledger"),
    5: .same(proto: "multi"),
    6: .same(proto: "offline"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pubKey) }()
      case 3: try {
        var v: Cosmos_Crypto_Keyring_V1_Record.Local?
        var hadOneofValue = false
        if let current = self.item {
          hadOneofValue = true
          if case .local(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.item = .local(v)
        }
      }()
      case 4: try {
        var v: Cosmos_Crypto_Keyring_V1_Record.Ledger?
        var hadOneofValue = false
        if let current = self.item {
          hadOneofValue = true
          if case .ledger(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.item = .ledger(v)
        }
      }()
      case 5: try {
        var v: Cosmos_Crypto_Keyring_V1_Record.Multi?
        var hadOneofValue = false
        if let current = self.item {
          hadOneofValue = true
          if case .multi(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.item = .multi(v)
        }
      }()
      case 6: try {
        var v: Cosmos_Crypto_Keyring_V1_Record.Offline?
        var hadOneofValue = false
        if let current = self.item {
          hadOneofValue = true
          if case .offline(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.item = .offline(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if let v = self._pubKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.item {
    case .local?: try {
      guard case .local(let v)? = self.item else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .ledger?: try {
      guard case .ledger(let v)? = self.item else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .multi?: try {
      guard case .multi(let v)? = self.item else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .offline?: try {
      guard case .offline(let v)? = self.item else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Crypto_Keyring_V1_Record, rhs: Cosmos_Crypto_Keyring_V1_Record) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._pubKey != rhs._pubKey {return false}
    if lhs.item != rhs.item {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Crypto_Keyring_V1_Record.Local: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Cosmos_Crypto_Keyring_V1_Record.protoMessageName + ".Local"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "priv_key"),
    2: .standard(proto: "priv_key_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._privKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.privKeyType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._privKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.privKeyType.isEmpty {
      try visitor.visitSingularStringField(value: self.privKeyType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Crypto_Keyring_V1_Record.Local, rhs: Cosmos_Crypto_Keyring_V1_Record.Local) -> Bool {
    if lhs._privKey != rhs._privKey {return false}
    if lhs.privKeyType != rhs.privKeyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Crypto_Keyring_V1_Record.Ledger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Cosmos_Crypto_Keyring_V1_Record.protoMessageName + ".Ledger"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._path {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Crypto_Keyring_V1_Record.Ledger, rhs: Cosmos_Crypto_Keyring_V1_Record.Ledger) -> Bool {
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Crypto_Keyring_V1_Record.Multi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Cosmos_Crypto_Keyring_V1_Record.protoMessageName + ".Multi"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Crypto_Keyring_V1_Record.Multi, rhs: Cosmos_Crypto_Keyring_V1_Record.Multi) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Crypto_Keyring_V1_Record.Offline: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Cosmos_Crypto_Keyring_V1_Record.protoMessageName + ".Offline"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Crypto_Keyring_V1_Record.Offline, rhs: Cosmos_Crypto_Keyring_V1_Record.Offline) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
