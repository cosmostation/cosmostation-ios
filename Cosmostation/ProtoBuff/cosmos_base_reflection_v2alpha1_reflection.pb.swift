// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cosmos/base/reflection/v2alpha1/reflection.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// Since: cosmos-sdk 0.43

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// AppDescriptor describes a cosmos-sdk based application
struct Cosmos_Base_Reflection_V2alpha1_AppDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// AuthnDescriptor provides information on how to authenticate transactions on the application
  /// NOTE: experimental and subject to change in future releases.
  var authn: Cosmos_Base_Reflection_V2alpha1_AuthnDescriptor {
    get {return _authn ?? Cosmos_Base_Reflection_V2alpha1_AuthnDescriptor()}
    set {_authn = newValue}
  }
  /// Returns true if `authn` has been explicitly set.
  var hasAuthn: Bool {return self._authn != nil}
  /// Clears the value of `authn`. Subsequent reads from it will return its default value.
  mutating func clearAuthn() {self._authn = nil}

  /// chain provides the chain descriptor
  var chain: Cosmos_Base_Reflection_V2alpha1_ChainDescriptor {
    get {return _chain ?? Cosmos_Base_Reflection_V2alpha1_ChainDescriptor()}
    set {_chain = newValue}
  }
  /// Returns true if `chain` has been explicitly set.
  var hasChain: Bool {return self._chain != nil}
  /// Clears the value of `chain`. Subsequent reads from it will return its default value.
  mutating func clearChain() {self._chain = nil}

  /// codec provides metadata information regarding codec related types
  var codec: Cosmos_Base_Reflection_V2alpha1_CodecDescriptor {
    get {return _codec ?? Cosmos_Base_Reflection_V2alpha1_CodecDescriptor()}
    set {_codec = newValue}
  }
  /// Returns true if `codec` has been explicitly set.
  var hasCodec: Bool {return self._codec != nil}
  /// Clears the value of `codec`. Subsequent reads from it will return its default value.
  mutating func clearCodec() {self._codec = nil}

  /// configuration provides metadata information regarding the sdk.Config type
  var configuration: Cosmos_Base_Reflection_V2alpha1_ConfigurationDescriptor {
    get {return _configuration ?? Cosmos_Base_Reflection_V2alpha1_ConfigurationDescriptor()}
    set {_configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  var hasConfiguration: Bool {return self._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  mutating func clearConfiguration() {self._configuration = nil}

  /// query_services provides metadata information regarding the available queriable endpoints
  var queryServices: Cosmos_Base_Reflection_V2alpha1_QueryServicesDescriptor {
    get {return _queryServices ?? Cosmos_Base_Reflection_V2alpha1_QueryServicesDescriptor()}
    set {_queryServices = newValue}
  }
  /// Returns true if `queryServices` has been explicitly set.
  var hasQueryServices: Bool {return self._queryServices != nil}
  /// Clears the value of `queryServices`. Subsequent reads from it will return its default value.
  mutating func clearQueryServices() {self._queryServices = nil}

  /// tx provides metadata information regarding how to send transactions to the given application
  var tx: Cosmos_Base_Reflection_V2alpha1_TxDescriptor {
    get {return _tx ?? Cosmos_Base_Reflection_V2alpha1_TxDescriptor()}
    set {_tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  var hasTx: Bool {return self._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  mutating func clearTx() {self._tx = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _authn: Cosmos_Base_Reflection_V2alpha1_AuthnDescriptor? = nil
  fileprivate var _chain: Cosmos_Base_Reflection_V2alpha1_ChainDescriptor? = nil
  fileprivate var _codec: Cosmos_Base_Reflection_V2alpha1_CodecDescriptor? = nil
  fileprivate var _configuration: Cosmos_Base_Reflection_V2alpha1_ConfigurationDescriptor? = nil
  fileprivate var _queryServices: Cosmos_Base_Reflection_V2alpha1_QueryServicesDescriptor? = nil
  fileprivate var _tx: Cosmos_Base_Reflection_V2alpha1_TxDescriptor? = nil
}

/// TxDescriptor describes the accepted transaction type
struct Cosmos_Base_Reflection_V2alpha1_TxDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// fullname is the protobuf fullname of the raw transaction type (for instance the tx.Tx type)
  /// it is not meant to support polymorphism of transaction types, it is supposed to be used by
  /// reflection clients to understand if they can handle a specific transaction type in an application.
  var fullname: String = String()

  /// msgs lists the accepted application messages (sdk.Msg)
  var msgs: [Cosmos_Base_Reflection_V2alpha1_MsgDescriptor] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AuthnDescriptor provides information on how to sign transactions without relying
/// on the online RPCs GetTxMetadata and CombineUnsignedTxAndSignatures
struct Cosmos_Base_Reflection_V2alpha1_AuthnDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// sign_modes defines the supported signature algorithm
  var signModes: [Cosmos_Base_Reflection_V2alpha1_SigningModeDescriptor] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SigningModeDescriptor provides information on a signing flow of the application
/// NOTE(fdymylja): here we could go as far as providing an entire flow on how
/// to sign a message given a SigningModeDescriptor, but it's better to think about
/// this another time
struct Cosmos_Base_Reflection_V2alpha1_SigningModeDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name defines the unique name of the signing mode
  var name: String = String()

  /// number is the unique int32 identifier for the sign_mode enum
  var number: Int32 = 0

  /// authn_info_provider_method_fullname defines the fullname of the method to call to get
  /// the metadata required to authenticate using the provided sign_modes
  var authnInfoProviderMethodFullname: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ChainDescriptor describes chain information of the application
struct Cosmos_Base_Reflection_V2alpha1_ChainDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id is the chain id
  var id: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// CodecDescriptor describes the registered interfaces and provides metadata information on the types
struct Cosmos_Base_Reflection_V2alpha1_CodecDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// interfaces is a list of the registerted interfaces descriptors
  var interfaces: [Cosmos_Base_Reflection_V2alpha1_InterfaceDescriptor] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// InterfaceDescriptor describes the implementation of an interface
struct Cosmos_Base_Reflection_V2alpha1_InterfaceDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// fullname is the name of the interface
  var fullname: String = String()

  /// interface_accepting_messages contains information regarding the proto messages which contain the interface as
  /// google.protobuf.Any field
  var interfaceAcceptingMessages: [Cosmos_Base_Reflection_V2alpha1_InterfaceAcceptingMessageDescriptor] = []

  /// interface_implementers is a list of the descriptors of the interface implementers
  var interfaceImplementers: [Cosmos_Base_Reflection_V2alpha1_InterfaceImplementerDescriptor] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// InterfaceImplementerDescriptor describes an interface implementer
struct Cosmos_Base_Reflection_V2alpha1_InterfaceImplementerDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// fullname is the protobuf queryable name of the interface implementer
  var fullname: String = String()

  /// type_url defines the type URL used when marshalling the type as any
  /// this is required so we can provide type safe google.protobuf.Any marshalling and
  /// unmarshalling, making sure that we don't accept just 'any' type
  /// in our interface fields
  var typeURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// InterfaceAcceptingMessageDescriptor describes a protobuf message which contains
/// an interface represented as a google.protobuf.Any
struct Cosmos_Base_Reflection_V2alpha1_InterfaceAcceptingMessageDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// fullname is the protobuf fullname of the type containing the interface
  var fullname: String = String()

  /// field_descriptor_names is a list of the protobuf name (not fullname) of the field
  /// which contains the interface as google.protobuf.Any (the interface is the same, but
  /// it can be in multiple fields of the same proto message)
  var fieldDescriptorNames: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ConfigurationDescriptor contains metadata information on the sdk.Config
struct Cosmos_Base_Reflection_V2alpha1_ConfigurationDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// bech32_account_address_prefix is the account address prefix
  var bech32AccountAddressPrefix: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgDescriptor describes a cosmos-sdk message that can be delivered with a transaction
struct Cosmos_Base_Reflection_V2alpha1_MsgDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// msg_type_url contains the TypeURL of a sdk.Msg.
  var msgTypeURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAuthnDescriptorRequest is the request used for the GetAuthnDescriptor RPC
struct Cosmos_Base_Reflection_V2alpha1_GetAuthnDescriptorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetAuthnDescriptorResponse is the response returned by the GetAuthnDescriptor RPC
struct Cosmos_Base_Reflection_V2alpha1_GetAuthnDescriptorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// authn describes how to authenticate to the application when sending transactions
  var authn: Cosmos_Base_Reflection_V2alpha1_AuthnDescriptor {
    get {return _authn ?? Cosmos_Base_Reflection_V2alpha1_AuthnDescriptor()}
    set {_authn = newValue}
  }
  /// Returns true if `authn` has been explicitly set.
  var hasAuthn: Bool {return self._authn != nil}
  /// Clears the value of `authn`. Subsequent reads from it will return its default value.
  mutating func clearAuthn() {self._authn = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _authn: Cosmos_Base_Reflection_V2alpha1_AuthnDescriptor? = nil
}

/// GetChainDescriptorRequest is the request used for the GetChainDescriptor RPC
struct Cosmos_Base_Reflection_V2alpha1_GetChainDescriptorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetChainDescriptorResponse is the response returned by the GetChainDescriptor RPC
struct Cosmos_Base_Reflection_V2alpha1_GetChainDescriptorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// chain describes application chain information
  var chain: Cosmos_Base_Reflection_V2alpha1_ChainDescriptor {
    get {return _chain ?? Cosmos_Base_Reflection_V2alpha1_ChainDescriptor()}
    set {_chain = newValue}
  }
  /// Returns true if `chain` has been explicitly set.
  var hasChain: Bool {return self._chain != nil}
  /// Clears the value of `chain`. Subsequent reads from it will return its default value.
  mutating func clearChain() {self._chain = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chain: Cosmos_Base_Reflection_V2alpha1_ChainDescriptor? = nil
}

/// GetCodecDescriptorRequest is the request used for the GetCodecDescriptor RPC
struct Cosmos_Base_Reflection_V2alpha1_GetCodecDescriptorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetCodecDescriptorResponse is the response returned by the GetCodecDescriptor RPC
struct Cosmos_Base_Reflection_V2alpha1_GetCodecDescriptorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// codec describes the application codec such as registered interfaces and implementations
  var codec: Cosmos_Base_Reflection_V2alpha1_CodecDescriptor {
    get {return _codec ?? Cosmos_Base_Reflection_V2alpha1_CodecDescriptor()}
    set {_codec = newValue}
  }
  /// Returns true if `codec` has been explicitly set.
  var hasCodec: Bool {return self._codec != nil}
  /// Clears the value of `codec`. Subsequent reads from it will return its default value.
  mutating func clearCodec() {self._codec = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _codec: Cosmos_Base_Reflection_V2alpha1_CodecDescriptor? = nil
}

/// GetConfigurationDescriptorRequest is the request used for the GetConfigurationDescriptor RPC
struct Cosmos_Base_Reflection_V2alpha1_GetConfigurationDescriptorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetConfigurationDescriptorResponse is the response returned by the GetConfigurationDescriptor RPC
struct Cosmos_Base_Reflection_V2alpha1_GetConfigurationDescriptorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// config describes the application's sdk.Config
  var config: Cosmos_Base_Reflection_V2alpha1_ConfigurationDescriptor {
    get {return _config ?? Cosmos_Base_Reflection_V2alpha1_ConfigurationDescriptor()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {self._config = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _config: Cosmos_Base_Reflection_V2alpha1_ConfigurationDescriptor? = nil
}

/// GetQueryServicesDescriptorRequest is the request used for the GetQueryServicesDescriptor RPC
struct Cosmos_Base_Reflection_V2alpha1_GetQueryServicesDescriptorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetQueryServicesDescriptorResponse is the response returned by the GetQueryServicesDescriptor RPC
struct Cosmos_Base_Reflection_V2alpha1_GetQueryServicesDescriptorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// queries provides information on the available queryable services
  var queries: Cosmos_Base_Reflection_V2alpha1_QueryServicesDescriptor {
    get {return _queries ?? Cosmos_Base_Reflection_V2alpha1_QueryServicesDescriptor()}
    set {_queries = newValue}
  }
  /// Returns true if `queries` has been explicitly set.
  var hasQueries: Bool {return self._queries != nil}
  /// Clears the value of `queries`. Subsequent reads from it will return its default value.
  mutating func clearQueries() {self._queries = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _queries: Cosmos_Base_Reflection_V2alpha1_QueryServicesDescriptor? = nil
}

/// GetTxDescriptorRequest is the request used for the GetTxDescriptor RPC
struct Cosmos_Base_Reflection_V2alpha1_GetTxDescriptorRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// GetTxDescriptorResponse is the response returned by the GetTxDescriptor RPC
struct Cosmos_Base_Reflection_V2alpha1_GetTxDescriptorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// tx provides information on msgs that can be forwarded to the application
  /// alongside the accepted transaction protobuf type
  var tx: Cosmos_Base_Reflection_V2alpha1_TxDescriptor {
    get {return _tx ?? Cosmos_Base_Reflection_V2alpha1_TxDescriptor()}
    set {_tx = newValue}
  }
  /// Returns true if `tx` has been explicitly set.
  var hasTx: Bool {return self._tx != nil}
  /// Clears the value of `tx`. Subsequent reads from it will return its default value.
  mutating func clearTx() {self._tx = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tx: Cosmos_Base_Reflection_V2alpha1_TxDescriptor? = nil
}

/// QueryServicesDescriptor contains the list of cosmos-sdk queriable services
struct Cosmos_Base_Reflection_V2alpha1_QueryServicesDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// query_services is a list of cosmos-sdk QueryServiceDescriptor
  var queryServices: [Cosmos_Base_Reflection_V2alpha1_QueryServiceDescriptor] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryServiceDescriptor describes a cosmos-sdk queryable service
struct Cosmos_Base_Reflection_V2alpha1_QueryServiceDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// fullname is the protobuf fullname of the service descriptor
  var fullname: String = String()

  /// is_module describes if this service is actually exposed by an application's module
  var isModule: Bool = false

  /// methods provides a list of query service methods
  var methods: [Cosmos_Base_Reflection_V2alpha1_QueryMethodDescriptor] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryMethodDescriptor describes a queryable method of a query service
/// no other info is provided beside method name and tendermint queryable path
/// because it would be redundant with the grpc reflection service
struct Cosmos_Base_Reflection_V2alpha1_QueryMethodDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// name is the protobuf name (not fullname) of the method
  var name: String = String()

  /// full_query_path is the path that can be used to query
  /// this method via tendermint abci.Query
  var fullQueryPath: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cosmos.base.reflection.v2alpha1"

extension Cosmos_Base_Reflection_V2alpha1_AppDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AppDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authn"),
    2: .same(proto: "chain"),
    3: .same(proto: "codec"),
    4: .same(proto: "configuration"),
    5: .standard(proto: "query_services"),
    6: .same(proto: "tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authn) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._chain) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._codec) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._queryServices) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._tx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._authn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._chain {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._codec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._queryServices {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._tx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_AppDescriptor, rhs: Cosmos_Base_Reflection_V2alpha1_AppDescriptor) -> Bool {
    if lhs._authn != rhs._authn {return false}
    if lhs._chain != rhs._chain {return false}
    if lhs._codec != rhs._codec {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs._queryServices != rhs._queryServices {return false}
    if lhs._tx != rhs._tx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_TxDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fullname"),
    2: .same(proto: "msgs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fullname) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.msgs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fullname.isEmpty {
      try visitor.visitSingularStringField(value: self.fullname, fieldNumber: 1)
    }
    if !self.msgs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.msgs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_TxDescriptor, rhs: Cosmos_Base_Reflection_V2alpha1_TxDescriptor) -> Bool {
    if lhs.fullname != rhs.fullname {return false}
    if lhs.msgs != rhs.msgs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_AuthnDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthnDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sign_modes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.signModes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signModes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signModes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_AuthnDescriptor, rhs: Cosmos_Base_Reflection_V2alpha1_AuthnDescriptor) -> Bool {
    if lhs.signModes != rhs.signModes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_SigningModeDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SigningModeDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "number"),
    3: .standard(proto: "authn_info_provider_method_fullname"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.number) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.authnInfoProviderMethodFullname) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.number != 0 {
      try visitor.visitSingularInt32Field(value: self.number, fieldNumber: 2)
    }
    if !self.authnInfoProviderMethodFullname.isEmpty {
      try visitor.visitSingularStringField(value: self.authnInfoProviderMethodFullname, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_SigningModeDescriptor, rhs: Cosmos_Base_Reflection_V2alpha1_SigningModeDescriptor) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.number != rhs.number {return false}
    if lhs.authnInfoProviderMethodFullname != rhs.authnInfoProviderMethodFullname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_ChainDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ChainDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_ChainDescriptor, rhs: Cosmos_Base_Reflection_V2alpha1_ChainDescriptor) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_CodecDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CodecDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "interfaces"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.interfaces) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.interfaces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.interfaces, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_CodecDescriptor, rhs: Cosmos_Base_Reflection_V2alpha1_CodecDescriptor) -> Bool {
    if lhs.interfaces != rhs.interfaces {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_InterfaceDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InterfaceDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fullname"),
    2: .standard(proto: "interface_accepting_messages"),
    3: .standard(proto: "interface_implementers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fullname) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.interfaceAcceptingMessages) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.interfaceImplementers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fullname.isEmpty {
      try visitor.visitSingularStringField(value: self.fullname, fieldNumber: 1)
    }
    if !self.interfaceAcceptingMessages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.interfaceAcceptingMessages, fieldNumber: 2)
    }
    if !self.interfaceImplementers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.interfaceImplementers, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_InterfaceDescriptor, rhs: Cosmos_Base_Reflection_V2alpha1_InterfaceDescriptor) -> Bool {
    if lhs.fullname != rhs.fullname {return false}
    if lhs.interfaceAcceptingMessages != rhs.interfaceAcceptingMessages {return false}
    if lhs.interfaceImplementers != rhs.interfaceImplementers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_InterfaceImplementerDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InterfaceImplementerDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fullname"),
    2: .standard(proto: "type_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fullname) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.typeURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fullname.isEmpty {
      try visitor.visitSingularStringField(value: self.fullname, fieldNumber: 1)
    }
    if !self.typeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.typeURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_InterfaceImplementerDescriptor, rhs: Cosmos_Base_Reflection_V2alpha1_InterfaceImplementerDescriptor) -> Bool {
    if lhs.fullname != rhs.fullname {return false}
    if lhs.typeURL != rhs.typeURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_InterfaceAcceptingMessageDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InterfaceAcceptingMessageDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fullname"),
    2: .standard(proto: "field_descriptor_names"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fullname) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.fieldDescriptorNames) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fullname.isEmpty {
      try visitor.visitSingularStringField(value: self.fullname, fieldNumber: 1)
    }
    if !self.fieldDescriptorNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fieldDescriptorNames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_InterfaceAcceptingMessageDescriptor, rhs: Cosmos_Base_Reflection_V2alpha1_InterfaceAcceptingMessageDescriptor) -> Bool {
    if lhs.fullname != rhs.fullname {return false}
    if lhs.fieldDescriptorNames != rhs.fieldDescriptorNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_ConfigurationDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfigurationDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bech32_account_address_prefix"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.bech32AccountAddressPrefix) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bech32AccountAddressPrefix.isEmpty {
      try visitor.visitSingularStringField(value: self.bech32AccountAddressPrefix, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_ConfigurationDescriptor, rhs: Cosmos_Base_Reflection_V2alpha1_ConfigurationDescriptor) -> Bool {
    if lhs.bech32AccountAddressPrefix != rhs.bech32AccountAddressPrefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_MsgDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "msg_type_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.msgTypeURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msgTypeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.msgTypeURL, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_MsgDescriptor, rhs: Cosmos_Base_Reflection_V2alpha1_MsgDescriptor) -> Bool {
    if lhs.msgTypeURL != rhs.msgTypeURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_GetAuthnDescriptorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAuthnDescriptorRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_GetAuthnDescriptorRequest, rhs: Cosmos_Base_Reflection_V2alpha1_GetAuthnDescriptorRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_GetAuthnDescriptorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetAuthnDescriptorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "authn"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authn) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._authn {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_GetAuthnDescriptorResponse, rhs: Cosmos_Base_Reflection_V2alpha1_GetAuthnDescriptorResponse) -> Bool {
    if lhs._authn != rhs._authn {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_GetChainDescriptorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetChainDescriptorRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_GetChainDescriptorRequest, rhs: Cosmos_Base_Reflection_V2alpha1_GetChainDescriptorRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_GetChainDescriptorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetChainDescriptorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._chain) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._chain {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_GetChainDescriptorResponse, rhs: Cosmos_Base_Reflection_V2alpha1_GetChainDescriptorResponse) -> Bool {
    if lhs._chain != rhs._chain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_GetCodecDescriptorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetCodecDescriptorRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_GetCodecDescriptorRequest, rhs: Cosmos_Base_Reflection_V2alpha1_GetCodecDescriptorRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_GetCodecDescriptorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetCodecDescriptorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codec"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._codec) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._codec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_GetCodecDescriptorResponse, rhs: Cosmos_Base_Reflection_V2alpha1_GetCodecDescriptorResponse) -> Bool {
    if lhs._codec != rhs._codec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_GetConfigurationDescriptorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConfigurationDescriptorRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_GetConfigurationDescriptorRequest, rhs: Cosmos_Base_Reflection_V2alpha1_GetConfigurationDescriptorRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_GetConfigurationDescriptorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetConfigurationDescriptorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_GetConfigurationDescriptorResponse, rhs: Cosmos_Base_Reflection_V2alpha1_GetConfigurationDescriptorResponse) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_GetQueryServicesDescriptorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetQueryServicesDescriptorRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_GetQueryServicesDescriptorRequest, rhs: Cosmos_Base_Reflection_V2alpha1_GetQueryServicesDescriptorRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_GetQueryServicesDescriptorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetQueryServicesDescriptorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "queries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._queries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._queries {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_GetQueryServicesDescriptorResponse, rhs: Cosmos_Base_Reflection_V2alpha1_GetQueryServicesDescriptorResponse) -> Bool {
    if lhs._queries != rhs._queries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_GetTxDescriptorRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTxDescriptorRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_GetTxDescriptorRequest, rhs: Cosmos_Base_Reflection_V2alpha1_GetTxDescriptorRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_GetTxDescriptorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTxDescriptorResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._tx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._tx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_GetTxDescriptorResponse, rhs: Cosmos_Base_Reflection_V2alpha1_GetTxDescriptorResponse) -> Bool {
    if lhs._tx != rhs._tx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_QueryServicesDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryServicesDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "query_services"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.queryServices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.queryServices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.queryServices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_QueryServicesDescriptor, rhs: Cosmos_Base_Reflection_V2alpha1_QueryServicesDescriptor) -> Bool {
    if lhs.queryServices != rhs.queryServices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_QueryServiceDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryServiceDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fullname"),
    2: .standard(proto: "is_module"),
    3: .same(proto: "methods"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.fullname) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isModule) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.methods) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fullname.isEmpty {
      try visitor.visitSingularStringField(value: self.fullname, fieldNumber: 1)
    }
    if self.isModule != false {
      try visitor.visitSingularBoolField(value: self.isModule, fieldNumber: 2)
    }
    if !self.methods.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.methods, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_QueryServiceDescriptor, rhs: Cosmos_Base_Reflection_V2alpha1_QueryServiceDescriptor) -> Bool {
    if lhs.fullname != rhs.fullname {return false}
    if lhs.isModule != rhs.isModule {return false}
    if lhs.methods != rhs.methods {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Base_Reflection_V2alpha1_QueryMethodDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMethodDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "full_query_path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fullQueryPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.fullQueryPath.isEmpty {
      try visitor.visitSingularStringField(value: self.fullQueryPath, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Base_Reflection_V2alpha1_QueryMethodDescriptor, rhs: Cosmos_Base_Reflection_V2alpha1_QueryMethodDescriptor) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.fullQueryPath != rhs.fullQueryPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
