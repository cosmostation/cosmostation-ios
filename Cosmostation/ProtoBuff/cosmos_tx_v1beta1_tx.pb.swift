// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cosmos/tx/v1beta1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Tx is the standard type used for broadcasting transactions.
struct Cosmos_Tx_V1beta1_Tx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// body is the processable content of the transaction
  var body: Cosmos_Tx_V1beta1_TxBody {
    get {return _body ?? Cosmos_Tx_V1beta1_TxBody()}
    set {_body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return self._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {self._body = nil}

  /// auth_info is the authorization related content of the transaction,
  /// specifically signers, signer modes and fee
  var authInfo: Cosmos_Tx_V1beta1_AuthInfo {
    get {return _authInfo ?? Cosmos_Tx_V1beta1_AuthInfo()}
    set {_authInfo = newValue}
  }
  /// Returns true if `authInfo` has been explicitly set.
  var hasAuthInfo: Bool {return self._authInfo != nil}
  /// Clears the value of `authInfo`. Subsequent reads from it will return its default value.
  mutating func clearAuthInfo() {self._authInfo = nil}

  /// signatures is a list of signatures that matches the length and order of
  /// AuthInfo's signer_infos to allow connecting signature meta information like
  /// public key and signing mode by position.
  var signatures: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _body: Cosmos_Tx_V1beta1_TxBody? = nil
  fileprivate var _authInfo: Cosmos_Tx_V1beta1_AuthInfo? = nil
}

/// TxRaw is a variant of Tx that pins the signer's exact binary representation
/// of body and auth_info. This is used for signing, broadcasting and
/// verification. The binary `serialize(tx: TxRaw)` is stored in Tendermint and
/// the hash `sha256(serialize(tx: TxRaw))` becomes the "txhash", commonly used
/// as the transaction ID.
struct Cosmos_Tx_V1beta1_TxRaw {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// body_bytes is a protobuf serialization of a TxBody that matches the
  /// representation in SignDoc.
  var bodyBytes: Data = Data()

  /// auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
  /// representation in SignDoc.
  var authInfoBytes: Data = Data()

  /// signatures is a list of signatures that matches the length and order of
  /// AuthInfo's signer_infos to allow connecting signature meta information like
  /// public key and signing mode by position.
  var signatures: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SignDoc is the type used for generating sign bytes for SIGN_MODE_DIRECT.
struct Cosmos_Tx_V1beta1_SignDoc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// body_bytes is protobuf serialization of a TxBody that matches the
  /// representation in TxRaw.
  var bodyBytes: Data = Data()

  /// auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
  /// representation in TxRaw.
  var authInfoBytes: Data = Data()

  /// chain_id is the unique identifier of the chain this transaction targets.
  /// It prevents signed transactions from being used on another chain by an
  /// attacker
  var chainID: String = String()

  /// account_number is the account number of the account in state
  var accountNumber: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// SignDocDirectAux is the type used for generating sign bytes for
/// SIGN_MODE_DIRECT_AUX.
struct Cosmos_Tx_V1beta1_SignDocDirectAux {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// body_bytes is protobuf serialization of a TxBody that matches the
  /// representation in TxRaw.
  var bodyBytes: Data = Data()

  /// public_key is the public key of the signing account.
  var publicKey: Google_Protobuf_Any {
    get {return _publicKey ?? Google_Protobuf_Any()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  /// chain_id is the identifier of the chain this transaction targets.
  /// It prevents signed transactions from being used on another chain by an
  /// attacker.
  var chainID: String = String()

  /// account_number is the account number of the account in state.
  var accountNumber: UInt64 = 0

  /// sequence is the sequence number of the signing account.
  var sequence: UInt64 = 0

  /// Tip is the optional tip used for meta-transactions. It should be left
  /// empty if the signer is not the tipper for this transaction.
  var tip: Cosmos_Tx_V1beta1_Tip {
    get {return _tip ?? Cosmos_Tx_V1beta1_Tip()}
    set {_tip = newValue}
  }
  /// Returns true if `tip` has been explicitly set.
  var hasTip: Bool {return self._tip != nil}
  /// Clears the value of `tip`. Subsequent reads from it will return its default value.
  mutating func clearTip() {self._tip = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publicKey: Google_Protobuf_Any? = nil
  fileprivate var _tip: Cosmos_Tx_V1beta1_Tip? = nil
}

/// TxBody is the body of a transaction that all signers sign over.
struct Cosmos_Tx_V1beta1_TxBody {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// messages is a list of messages to be executed. The required signers of
  /// those messages define the number and order of elements in AuthInfo's
  /// signer_infos and Tx's signatures. Each required signer address is added to
  /// the list only the first time it occurs.
  /// By convention, the first required signer (usually from the first message)
  /// is referred to as the primary signer and pays the fee for the whole
  /// transaction.
  var messages: [Google_Protobuf_Any] = []

  /// memo is any arbitrary note/comment to be added to the transaction.
  /// WARNING: in clients, any publicly exposed text should not be called memo,
  /// but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
  var memo: String = String()

  /// timeout is the block height after which this transaction will not
  /// be processed by the chain
  var timeoutHeight: UInt64 = 0

  /// extension_options are arbitrary options that can be added by chains
  /// when the default options are not sufficient. If any of these are present
  /// and can't be handled, the transaction will be rejected
  var extensionOptions: [Google_Protobuf_Any] = []

  /// extension_options are arbitrary options that can be added by chains
  /// when the default options are not sufficient. If any of these are present
  /// and can't be handled, they will be ignored
  var nonCriticalExtensionOptions: [Google_Protobuf_Any] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AuthInfo describes the fee and signer modes that are used to sign a
/// transaction.
struct Cosmos_Tx_V1beta1_AuthInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// signer_infos defines the signing modes for the required signers. The number
  /// and order of elements must match the required signers from TxBody's
  /// messages. The first element is the primary signer and the one which pays
  /// the fee.
  var signerInfos: [Cosmos_Tx_V1beta1_SignerInfo] = []

  /// Fee is the fee and gas limit for the transaction. The first signer is the
  /// primary signer and the one which pays the fee. The fee can be calculated
  /// based on the cost of evaluating the body and doing signature verification
  /// of the signers. This can be estimated via simulation.
  var fee: Cosmos_Tx_V1beta1_Fee {
    get {return _fee ?? Cosmos_Tx_V1beta1_Fee()}
    set {_fee = newValue}
  }
  /// Returns true if `fee` has been explicitly set.
  var hasFee: Bool {return self._fee != nil}
  /// Clears the value of `fee`. Subsequent reads from it will return its default value.
  mutating func clearFee() {self._fee = nil}

  /// Tip is the optional tip used for meta-transactions.
  ///
  /// Since: cosmos-sdk 0.45
  var tip: Cosmos_Tx_V1beta1_Tip {
    get {return _tip ?? Cosmos_Tx_V1beta1_Tip()}
    set {_tip = newValue}
  }
  /// Returns true if `tip` has been explicitly set.
  var hasTip: Bool {return self._tip != nil}
  /// Clears the value of `tip`. Subsequent reads from it will return its default value.
  mutating func clearTip() {self._tip = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fee: Cosmos_Tx_V1beta1_Fee? = nil
  fileprivate var _tip: Cosmos_Tx_V1beta1_Tip? = nil
}

/// SignerInfo describes the public key and signing mode of a single top-level
/// signer.
struct Cosmos_Tx_V1beta1_SignerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// public_key is the public key of the signer. It is optional for accounts
  /// that already exist in state. If unset, the verifier can use the required \
  /// signer address for this position and lookup the public key.
  var publicKey: Google_Protobuf_Any {
    get {return _publicKey ?? Google_Protobuf_Any()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  /// mode_info describes the signing mode of the signer and is a nested
  /// structure to support nested multisig pubkey's
  var modeInfo: Cosmos_Tx_V1beta1_ModeInfo {
    get {return _modeInfo ?? Cosmos_Tx_V1beta1_ModeInfo()}
    set {_modeInfo = newValue}
  }
  /// Returns true if `modeInfo` has been explicitly set.
  var hasModeInfo: Bool {return self._modeInfo != nil}
  /// Clears the value of `modeInfo`. Subsequent reads from it will return its default value.
  mutating func clearModeInfo() {self._modeInfo = nil}

  /// sequence is the sequence of the account, which describes the
  /// number of committed transactions signed by a given address. It is used to
  /// prevent replay attacks.
  var sequence: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publicKey: Google_Protobuf_Any? = nil
  fileprivate var _modeInfo: Cosmos_Tx_V1beta1_ModeInfo? = nil
}

/// ModeInfo describes the signing mode of a single or nested multisig signer.
struct Cosmos_Tx_V1beta1_ModeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// sum is the oneof that specifies whether this represents a single or nested
  /// multisig signer
  var sum: Cosmos_Tx_V1beta1_ModeInfo.OneOf_Sum? = nil

  /// single represents a single signer
  var single: Cosmos_Tx_V1beta1_ModeInfo.Single {
    get {
      if case .single(let v)? = sum {return v}
      return Cosmos_Tx_V1beta1_ModeInfo.Single()
    }
    set {sum = .single(newValue)}
  }

  /// multi represents a nested multisig signer
  var multi: Cosmos_Tx_V1beta1_ModeInfo.Multi {
    get {
      if case .multi(let v)? = sum {return v}
      return Cosmos_Tx_V1beta1_ModeInfo.Multi()
    }
    set {sum = .multi(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// sum is the oneof that specifies whether this represents a single or nested
  /// multisig signer
  enum OneOf_Sum: Equatable {
    /// single represents a single signer
    case single(Cosmos_Tx_V1beta1_ModeInfo.Single)
    /// multi represents a nested multisig signer
    case multi(Cosmos_Tx_V1beta1_ModeInfo.Multi)

  #if !swift(>=4.1)
    static func ==(lhs: Cosmos_Tx_V1beta1_ModeInfo.OneOf_Sum, rhs: Cosmos_Tx_V1beta1_ModeInfo.OneOf_Sum) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.single, .single): return {
        guard case .single(let l) = lhs, case .single(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multi, .multi): return {
        guard case .multi(let l) = lhs, case .multi(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Single is the mode info for a single signer. It is structured as a message
  /// to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the
  /// future
  struct Single {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// mode is the signing mode of the single signer
    var mode: Cosmos_Tx_Signing_V1beta1_SignMode = .unspecified

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Multi is the mode info for a multisig public key
  struct Multi {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// bitarray specifies which keys within the multisig are signing
    var bitarray: Cosmos_Crypto_Multisig_V1beta1_CompactBitArray {
      get {return _bitarray ?? Cosmos_Crypto_Multisig_V1beta1_CompactBitArray()}
      set {_bitarray = newValue}
    }
    /// Returns true if `bitarray` has been explicitly set.
    var hasBitarray: Bool {return self._bitarray != nil}
    /// Clears the value of `bitarray`. Subsequent reads from it will return its default value.
    mutating func clearBitarray() {self._bitarray = nil}

    /// mode_infos is the corresponding modes of the signers of the multisig
    /// which could include nested multisig public keys
    var modeInfos: [Cosmos_Tx_V1beta1_ModeInfo] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _bitarray: Cosmos_Crypto_Multisig_V1beta1_CompactBitArray? = nil
  }

  init() {}
}

/// Fee includes the amount of coins paid in fees and the maximum
/// gas to be used by the transaction. The ratio yields an effective "gasprice",
/// which must be above some miminum to be accepted into the mempool.
struct Cosmos_Tx_V1beta1_Fee {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// amount is the amount of coins to be paid as a fee
  var amount: [Cosmos_Base_V1beta1_Coin] = []

  /// gas_limit is the maximum gas that can be used in transaction processing
  /// before an out of gas error occurs
  var gasLimit: UInt64 = 0

  /// if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
  /// the payer must be a tx signer (and thus have signed this field in AuthInfo).
  /// setting this field does *not* change the ordering of required signers for the transaction.
  var payer: String = String()

  /// if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
  /// to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
  /// not support fee grants, this will fail
  var granter: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Tip is the tip used for meta-transactions.
struct Cosmos_Tx_V1beta1_Tip {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// amount is the amount of the tip
  var amount: [Cosmos_Base_V1beta1_Coin] = []

  /// tipper is the address of the account paying for the tip
  var tipper: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// AuxSignerData is the intermediary format that an auxiliary signer (e.g. a
/// tipper) builds and sends to the fee payer (who will build and broadcast the
/// actual tx). AuxSignerData is not a valid tx in itself, and will be rejected
/// by the node if sent directly as-is.
///
/// Since: cosmos-sdk 0.45
struct Cosmos_Tx_V1beta1_AuxSignerData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address is the bech32-encoded address of the auxiliary signer. If using
  /// AuxSignerData across different chains, the bech32 prefix of the target
  /// chain (where the final transaction is broadcasted) should be used.
  var address: String = String()

  /// sign_doc is the SIGN_MOD_DIRECT_AUX sign doc that the auxiliary signer
  /// signs. Note: we use the same sign doc even if we're signing with
  /// LEGACY_AMINO_JSON.
  var signDoc: Cosmos_Tx_V1beta1_SignDocDirectAux {
    get {return _signDoc ?? Cosmos_Tx_V1beta1_SignDocDirectAux()}
    set {_signDoc = newValue}
  }
  /// Returns true if `signDoc` has been explicitly set.
  var hasSignDoc: Bool {return self._signDoc != nil}
  /// Clears the value of `signDoc`. Subsequent reads from it will return its default value.
  mutating func clearSignDoc() {self._signDoc = nil}

  /// mode is the signing mode of the single signer
  var mode: Cosmos_Tx_Signing_V1beta1_SignMode = .unspecified

  /// sig is the signature of the sign doc.
  var sig: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _signDoc: Cosmos_Tx_V1beta1_SignDocDirectAux? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cosmos.tx.v1beta1"

extension Cosmos_Tx_V1beta1_Tx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Tx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .standard(proto: "auth_info"),
    3: .same(proto: "signatures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._body) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authInfo) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.signatures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._body {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._authInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.signatures.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.signatures, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_Tx, rhs: Cosmos_Tx_V1beta1_Tx) -> Bool {
    if lhs._body != rhs._body {return false}
    if lhs._authInfo != rhs._authInfo {return false}
    if lhs.signatures != rhs.signatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_TxRaw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxRaw"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "body_bytes"),
    2: .standard(proto: "auth_info_bytes"),
    3: .same(proto: "signatures"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.bodyBytes) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.authInfoBytes) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.signatures) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bodyBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.bodyBytes, fieldNumber: 1)
    }
    if !self.authInfoBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.authInfoBytes, fieldNumber: 2)
    }
    if !self.signatures.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.signatures, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_TxRaw, rhs: Cosmos_Tx_V1beta1_TxRaw) -> Bool {
    if lhs.bodyBytes != rhs.bodyBytes {return false}
    if lhs.authInfoBytes != rhs.authInfoBytes {return false}
    if lhs.signatures != rhs.signatures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_SignDoc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignDoc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "body_bytes"),
    2: .standard(proto: "auth_info_bytes"),
    3: .standard(proto: "chain_id"),
    4: .standard(proto: "account_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.bodyBytes) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.authInfoBytes) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.accountNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bodyBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.bodyBytes, fieldNumber: 1)
    }
    if !self.authInfoBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.authInfoBytes, fieldNumber: 2)
    }
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 3)
    }
    if self.accountNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.accountNumber, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_SignDoc, rhs: Cosmos_Tx_V1beta1_SignDoc) -> Bool {
    if lhs.bodyBytes != rhs.bodyBytes {return false}
    if lhs.authInfoBytes != rhs.authInfoBytes {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs.accountNumber != rhs.accountNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_SignDocDirectAux: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignDocDirectAux"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "body_bytes"),
    2: .standard(proto: "public_key"),
    3: .standard(proto: "chain_id"),
    4: .standard(proto: "account_number"),
    5: .same(proto: "sequence"),
    6: .same(proto: "tip"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.bodyBytes) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.accountNumber) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.sequence) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._tip) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.bodyBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.bodyBytes, fieldNumber: 1)
    }
    if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 3)
    }
    if self.accountNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.accountNumber, fieldNumber: 4)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 5)
    }
    if let v = self._tip {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_SignDocDirectAux, rhs: Cosmos_Tx_V1beta1_SignDocDirectAux) -> Bool {
    if lhs.bodyBytes != rhs.bodyBytes {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs.accountNumber != rhs.accountNumber {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs._tip != rhs._tip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_TxBody: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxBody"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "messages"),
    2: .same(proto: "memo"),
    3: .standard(proto: "timeout_height"),
    1023: .standard(proto: "extension_options"),
    2047: .standard(proto: "non_critical_extension_options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.memo) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.timeoutHeight) }()
      case 1023: try { try decoder.decodeRepeatedMessageField(value: &self.extensionOptions) }()
      case 2047: try { try decoder.decodeRepeatedMessageField(value: &self.nonCriticalExtensionOptions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 1)
    }
    if !self.memo.isEmpty {
      try visitor.visitSingularStringField(value: self.memo, fieldNumber: 2)
    }
    if self.timeoutHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.timeoutHeight, fieldNumber: 3)
    }
    if !self.extensionOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.extensionOptions, fieldNumber: 1023)
    }
    if !self.nonCriticalExtensionOptions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.nonCriticalExtensionOptions, fieldNumber: 2047)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_TxBody, rhs: Cosmos_Tx_V1beta1_TxBody) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.memo != rhs.memo {return false}
    if lhs.timeoutHeight != rhs.timeoutHeight {return false}
    if lhs.extensionOptions != rhs.extensionOptions {return false}
    if lhs.nonCriticalExtensionOptions != rhs.nonCriticalExtensionOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_AuthInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signer_infos"),
    2: .same(proto: "fee"),
    3: .same(proto: "tip"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.signerInfos) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fee) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._tip) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signerInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.signerInfos, fieldNumber: 1)
    }
    if let v = self._fee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._tip {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_AuthInfo, rhs: Cosmos_Tx_V1beta1_AuthInfo) -> Bool {
    if lhs.signerInfos != rhs.signerInfos {return false}
    if lhs._fee != rhs._fee {return false}
    if lhs._tip != rhs._tip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_SignerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SignerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "public_key"),
    2: .standard(proto: "mode_info"),
    3: .same(proto: "sequence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._modeInfo) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.sequence) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._modeInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_SignerInfo, rhs: Cosmos_Tx_V1beta1_SignerInfo) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._modeInfo != rhs._modeInfo {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_ModeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ModeInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "single"),
    2: .same(proto: "multi"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Cosmos_Tx_V1beta1_ModeInfo.Single?
        var hadOneofValue = false
        if let current = self.sum {
          hadOneofValue = true
          if case .single(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sum = .single(v)
        }
      }()
      case 2: try {
        var v: Cosmos_Tx_V1beta1_ModeInfo.Multi?
        var hadOneofValue = false
        if let current = self.sum {
          hadOneofValue = true
          if case .multi(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.sum = .multi(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.sum {
    case .single?: try {
      guard case .single(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .multi?: try {
      guard case .multi(let v)? = self.sum else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_ModeInfo, rhs: Cosmos_Tx_V1beta1_ModeInfo) -> Bool {
    if lhs.sum != rhs.sum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_ModeInfo.Single: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Cosmos_Tx_V1beta1_ModeInfo.protoMessageName + ".Single"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .unspecified {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_ModeInfo.Single, rhs: Cosmos_Tx_V1beta1_ModeInfo.Single) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_ModeInfo.Multi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Cosmos_Tx_V1beta1_ModeInfo.protoMessageName + ".Multi"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bitarray"),
    2: .standard(proto: "mode_infos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bitarray) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.modeInfos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._bitarray {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.modeInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.modeInfos, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_ModeInfo.Multi, rhs: Cosmos_Tx_V1beta1_ModeInfo.Multi) -> Bool {
    if lhs._bitarray != rhs._bitarray {return false}
    if lhs.modeInfos != rhs.modeInfos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_Fee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Fee"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .standard(proto: "gas_limit"),
    3: .same(proto: "payer"),
    4: .same(proto: "granter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.gasLimit) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.payer) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.granter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 1)
    }
    if self.gasLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.gasLimit, fieldNumber: 2)
    }
    if !self.payer.isEmpty {
      try visitor.visitSingularStringField(value: self.payer, fieldNumber: 3)
    }
    if !self.granter.isEmpty {
      try visitor.visitSingularStringField(value: self.granter, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_Fee, rhs: Cosmos_Tx_V1beta1_Fee) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.gasLimit != rhs.gasLimit {return false}
    if lhs.payer != rhs.payer {return false}
    if lhs.granter != rhs.granter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_Tip: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Tip"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "amount"),
    2: .same(proto: "tipper"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.amount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.tipper) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 1)
    }
    if !self.tipper.isEmpty {
      try visitor.visitSingularStringField(value: self.tipper, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_Tip, rhs: Cosmos_Tx_V1beta1_Tip) -> Bool {
    if lhs.amount != rhs.amount {return false}
    if lhs.tipper != rhs.tipper {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Tx_V1beta1_AuxSignerData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuxSignerData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "sign_doc"),
    3: .same(proto: "mode"),
    4: .same(proto: "sig"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._signDoc) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.sig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if let v = self._signDoc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.mode != .unspecified {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 3)
    }
    if !self.sig.isEmpty {
      try visitor.visitSingularBytesField(value: self.sig, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Tx_V1beta1_AuxSignerData, rhs: Cosmos_Tx_V1beta1_AuxSignerData) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs._signDoc != rhs._signDoc {return false}
    if lhs.mode != rhs.mode {return false}
    if lhs.sig != rhs.sig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
