// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ibc/applications/fee/v1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MsgRegisterPayee defines the request type for the RegisterPayee rpc
struct Ibc_Applications_Fee_V1_MsgRegisterPayee {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unique port identifier
  var portID: String = String()

  /// unique channel identifier
  var channelID: String = String()

  /// the relayer address
  var relayer: String = String()

  /// the payee address
  var payee: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRegisterPayeeResponse defines the response type for the RegisterPayee rpc
struct Ibc_Applications_Fee_V1_MsgRegisterPayeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRegisterCounterpartyPayee defines the request type for the RegisterCounterpartyPayee rpc
struct Ibc_Applications_Fee_V1_MsgRegisterCounterpartyPayee {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unique port identifier
  var portID: String = String()

  /// unique channel identifier
  var channelID: String = String()

  /// the relayer address
  var relayer: String = String()

  /// the counterparty payee address
  var counterpartyPayee: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRegisterCounterpartyPayeeResponse defines the response type for the RegisterCounterpartyPayee rpc
struct Ibc_Applications_Fee_V1_MsgRegisterCounterpartyPayeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgPayPacketFee defines the request type for the PayPacketFee rpc
/// This Msg can be used to pay for a packet at the next sequence send & should be combined with the Msg that will be
/// paid for
struct Ibc_Applications_Fee_V1_MsgPayPacketFee {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// fee encapsulates the recv, ack and timeout fees associated with an IBC packet
  var fee: Ibc_Applications_Fee_V1_Fee {
    get {return _fee ?? Ibc_Applications_Fee_V1_Fee()}
    set {_fee = newValue}
  }
  /// Returns true if `fee` has been explicitly set.
  var hasFee: Bool {return self._fee != nil}
  /// Clears the value of `fee`. Subsequent reads from it will return its default value.
  mutating func clearFee() {self._fee = nil}

  /// the source port unique identifier
  var sourcePortID: String = String()

  /// the source channel unique identifer
  var sourceChannelID: String = String()

  /// account address to refund fee if necessary
  var signer: String = String()

  /// optional list of relayers permitted to the receive packet fees
  var relayers: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fee: Ibc_Applications_Fee_V1_Fee? = nil
}

/// MsgPayPacketFeeResponse defines the response type for the PayPacketFee rpc
struct Ibc_Applications_Fee_V1_MsgPayPacketFeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgPayPacketFeeAsync defines the request type for the PayPacketFeeAsync rpc
/// This Msg can be used to pay for a packet at a specified sequence (instead of the next sequence send)
struct Ibc_Applications_Fee_V1_MsgPayPacketFeeAsync {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unique packet identifier comprised of the channel ID, port ID and sequence
  var packetID: Ibc_Core_Channel_V1_PacketId {
    get {return _packetID ?? Ibc_Core_Channel_V1_PacketId()}
    set {_packetID = newValue}
  }
  /// Returns true if `packetID` has been explicitly set.
  var hasPacketID: Bool {return self._packetID != nil}
  /// Clears the value of `packetID`. Subsequent reads from it will return its default value.
  mutating func clearPacketID() {self._packetID = nil}

  /// the packet fee associated with a particular IBC packet
  var packetFee: Ibc_Applications_Fee_V1_PacketFee {
    get {return _packetFee ?? Ibc_Applications_Fee_V1_PacketFee()}
    set {_packetFee = newValue}
  }
  /// Returns true if `packetFee` has been explicitly set.
  var hasPacketFee: Bool {return self._packetFee != nil}
  /// Clears the value of `packetFee`. Subsequent reads from it will return its default value.
  mutating func clearPacketFee() {self._packetFee = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _packetID: Ibc_Core_Channel_V1_PacketId? = nil
  fileprivate var _packetFee: Ibc_Applications_Fee_V1_PacketFee? = nil
}

/// MsgPayPacketFeeAsyncResponse defines the response type for the PayPacketFeeAsync rpc
struct Ibc_Applications_Fee_V1_MsgPayPacketFeeAsyncResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Ibc_Applications_Fee_V1_MsgRegisterPayee: @unchecked Sendable {}
extension Ibc_Applications_Fee_V1_MsgRegisterPayeeResponse: @unchecked Sendable {}
extension Ibc_Applications_Fee_V1_MsgRegisterCounterpartyPayee: @unchecked Sendable {}
extension Ibc_Applications_Fee_V1_MsgRegisterCounterpartyPayeeResponse: @unchecked Sendable {}
extension Ibc_Applications_Fee_V1_MsgPayPacketFee: @unchecked Sendable {}
extension Ibc_Applications_Fee_V1_MsgPayPacketFeeResponse: @unchecked Sendable {}
extension Ibc_Applications_Fee_V1_MsgPayPacketFeeAsync: @unchecked Sendable {}
extension Ibc_Applications_Fee_V1_MsgPayPacketFeeAsyncResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ibc.applications.fee.v1"

extension Ibc_Applications_Fee_V1_MsgRegisterPayee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRegisterPayee"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "port_id"),
    2: .standard(proto: "channel_id"),
    3: .same(proto: "relayer"),
    4: .same(proto: "payee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.portID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.relayer) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.payee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.portID.isEmpty {
      try visitor.visitSingularStringField(value: self.portID, fieldNumber: 1)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 2)
    }
    if !self.relayer.isEmpty {
      try visitor.visitSingularStringField(value: self.relayer, fieldNumber: 3)
    }
    if !self.payee.isEmpty {
      try visitor.visitSingularStringField(value: self.payee, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Applications_Fee_V1_MsgRegisterPayee, rhs: Ibc_Applications_Fee_V1_MsgRegisterPayee) -> Bool {
    if lhs.portID != rhs.portID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.relayer != rhs.relayer {return false}
    if lhs.payee != rhs.payee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Applications_Fee_V1_MsgRegisterPayeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRegisterPayeeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Applications_Fee_V1_MsgRegisterPayeeResponse, rhs: Ibc_Applications_Fee_V1_MsgRegisterPayeeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Applications_Fee_V1_MsgRegisterCounterpartyPayee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRegisterCounterpartyPayee"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "port_id"),
    2: .standard(proto: "channel_id"),
    3: .same(proto: "relayer"),
    4: .standard(proto: "counterparty_payee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.portID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.relayer) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.counterpartyPayee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.portID.isEmpty {
      try visitor.visitSingularStringField(value: self.portID, fieldNumber: 1)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 2)
    }
    if !self.relayer.isEmpty {
      try visitor.visitSingularStringField(value: self.relayer, fieldNumber: 3)
    }
    if !self.counterpartyPayee.isEmpty {
      try visitor.visitSingularStringField(value: self.counterpartyPayee, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Applications_Fee_V1_MsgRegisterCounterpartyPayee, rhs: Ibc_Applications_Fee_V1_MsgRegisterCounterpartyPayee) -> Bool {
    if lhs.portID != rhs.portID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.relayer != rhs.relayer {return false}
    if lhs.counterpartyPayee != rhs.counterpartyPayee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Applications_Fee_V1_MsgRegisterCounterpartyPayeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRegisterCounterpartyPayeeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Applications_Fee_V1_MsgRegisterCounterpartyPayeeResponse, rhs: Ibc_Applications_Fee_V1_MsgRegisterCounterpartyPayeeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Applications_Fee_V1_MsgPayPacketFee: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPayPacketFee"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fee"),
    2: .standard(proto: "source_port_id"),
    3: .standard(proto: "source_channel_id"),
    4: .same(proto: "signer"),
    5: .same(proto: "relayers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._fee) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourcePortID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sourceChannelID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.signer) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.relayers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.sourcePortID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourcePortID, fieldNumber: 2)
    }
    if !self.sourceChannelID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceChannelID, fieldNumber: 3)
    }
    if !self.signer.isEmpty {
      try visitor.visitSingularStringField(value: self.signer, fieldNumber: 4)
    }
    if !self.relayers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.relayers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Applications_Fee_V1_MsgPayPacketFee, rhs: Ibc_Applications_Fee_V1_MsgPayPacketFee) -> Bool {
    if lhs._fee != rhs._fee {return false}
    if lhs.sourcePortID != rhs.sourcePortID {return false}
    if lhs.sourceChannelID != rhs.sourceChannelID {return false}
    if lhs.signer != rhs.signer {return false}
    if lhs.relayers != rhs.relayers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Applications_Fee_V1_MsgPayPacketFeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPayPacketFeeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Applications_Fee_V1_MsgPayPacketFeeResponse, rhs: Ibc_Applications_Fee_V1_MsgPayPacketFeeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Applications_Fee_V1_MsgPayPacketFeeAsync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPayPacketFeeAsync"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "packet_id"),
    2: .standard(proto: "packet_fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._packetID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._packetFee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._packetID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._packetFee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Applications_Fee_V1_MsgPayPacketFeeAsync, rhs: Ibc_Applications_Fee_V1_MsgPayPacketFeeAsync) -> Bool {
    if lhs._packetID != rhs._packetID {return false}
    if lhs._packetFee != rhs._packetFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ibc_Applications_Fee_V1_MsgPayPacketFeeAsyncResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgPayPacketFeeAsyncResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ibc_Applications_Fee_V1_MsgPayPacketFeeAsyncResponse, rhs: Ibc_Applications_Fee_V1_MsgPayPacketFeeAsyncResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
