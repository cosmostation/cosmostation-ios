// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: babylon/epoching/v1/events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// EventBeginEpoch is the event emitted when an epoch has started
struct Babylon_Epoching_V1_EventBeginEpoch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var epochNumber: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventEndEpoch is the event emitted when an epoch has ended
struct Babylon_Epoching_V1_EventEndEpoch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var epochNumber: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventHandleQueuedMsg is the event emitted when a queued message has been
/// handled
struct Babylon_Epoching_V1_EventHandleQueuedMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var originalEventType: String = String()

  var epochNumber: UInt64 = 0

  var height: UInt64 = 0

  var txID: Data = Data()

  var msgID: Data = Data()

  var originalAttributes: [Data] = []

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventSlashThreshold is the event emitted when a set of validators have been
/// slashed
struct Babylon_Epoching_V1_EventSlashThreshold {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var slashedVotingPower: Int64 = 0

  var totalVotingPower: Int64 = 0

  var slashedValidators: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventWrappedDelegate is the event emitted when a MsgWrappedDelegate has been
/// queued
struct Babylon_Epoching_V1_EventWrappedDelegate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var delegatorAddress: String = String()

  var validatorAddress: String = String()

  var amount: UInt64 = 0

  var denom: String = String()

  var epochBoundary: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventWrappedUndelegate is the event emitted when a MsgWrappedUndelegate has
/// been queued
struct Babylon_Epoching_V1_EventWrappedUndelegate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var delegatorAddress: String = String()

  var validatorAddress: String = String()

  var amount: UInt64 = 0

  var denom: String = String()

  var epochBoundary: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventWrappedBeginRedelegate is the event emitted when a
/// MsgWrappedBeginRedelegate has been queued
struct Babylon_Epoching_V1_EventWrappedBeginRedelegate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var delegatorAddress: String = String()

  var sourceValidatorAddress: String = String()

  var destinationValidatorAddress: String = String()

  var amount: UInt64 = 0

  var denom: String = String()

  var epochBoundary: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventWrappedCancelUnbondingDelegation is the event emitted when a
/// MsgWrappedCancelUnbondingDelegation has been queued
struct Babylon_Epoching_V1_EventWrappedCancelUnbondingDelegation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var delegatorAddress: String = String()

  var validatorAddress: String = String()

  var amount: UInt64 = 0

  var creationHeight: Int64 = 0

  var epochBoundary: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventWrappedEditValidator is the event emitted when a
/// MsgWrappedEditValidator has been queued
struct Babylon_Epoching_V1_EventWrappedEditValidator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var validatorAddress: String = String()

  var epochBoundary: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventWrappedStakingUpdateParams is the event emitted when a
/// MsgWrappedStakingUpdateParams has been queued
struct Babylon_Epoching_V1_EventWrappedStakingUpdateParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// unbonding_time is the time duration of unbonding.
  var unbondingTime: String = String()

  /// max_validators is the maximum number of validators.
  var maxValidators: UInt32 = 0

  /// max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).
  var maxEntries: UInt32 = 0

  /// historical_entries is the number of historical entries to persist.
  var historicalEntries: UInt32 = 0

  /// bond_denom defines the bondable coin denomination.
  var bondDenom: String = String()

  /// min_commission_rate is the chain-wide minimum commission rate that a validator can charge their delegators
  var minCommissionRate: String = String()

  var epochBoundary: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Babylon_Epoching_V1_EventBeginEpoch: @unchecked Sendable {}
extension Babylon_Epoching_V1_EventEndEpoch: @unchecked Sendable {}
extension Babylon_Epoching_V1_EventHandleQueuedMsg: @unchecked Sendable {}
extension Babylon_Epoching_V1_EventSlashThreshold: @unchecked Sendable {}
extension Babylon_Epoching_V1_EventWrappedDelegate: @unchecked Sendable {}
extension Babylon_Epoching_V1_EventWrappedUndelegate: @unchecked Sendable {}
extension Babylon_Epoching_V1_EventWrappedBeginRedelegate: @unchecked Sendable {}
extension Babylon_Epoching_V1_EventWrappedCancelUnbondingDelegation: @unchecked Sendable {}
extension Babylon_Epoching_V1_EventWrappedEditValidator: @unchecked Sendable {}
extension Babylon_Epoching_V1_EventWrappedStakingUpdateParams: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "babylon.epoching.v1"

extension Babylon_Epoching_V1_EventBeginEpoch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventBeginEpoch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epochNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_EventBeginEpoch, rhs: Babylon_Epoching_V1_EventBeginEpoch) -> Bool {
    if lhs.epochNumber != rhs.epochNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_EventEndEpoch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventEndEpoch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "epoch_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.epochNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.epochNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNumber, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_EventEndEpoch, rhs: Babylon_Epoching_V1_EventEndEpoch) -> Bool {
    if lhs.epochNumber != rhs.epochNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_EventHandleQueuedMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventHandleQueuedMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "original_event_type"),
    2: .standard(proto: "epoch_number"),
    3: .same(proto: "height"),
    4: .standard(proto: "tx_id"),
    5: .standard(proto: "msg_id"),
    6: .standard(proto: "original_attributes"),
    7: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.originalEventType) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.epochNumber) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.txID) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.msgID) }()
      case 6: try { try decoder.decodeRepeatedBytesField(value: &self.originalAttributes) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.originalEventType.isEmpty {
      try visitor.visitSingularStringField(value: self.originalEventType, fieldNumber: 1)
    }
    if self.epochNumber != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochNumber, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 3)
    }
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 4)
    }
    if !self.msgID.isEmpty {
      try visitor.visitSingularBytesField(value: self.msgID, fieldNumber: 5)
    }
    if !self.originalAttributes.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.originalAttributes, fieldNumber: 6)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_EventHandleQueuedMsg, rhs: Babylon_Epoching_V1_EventHandleQueuedMsg) -> Bool {
    if lhs.originalEventType != rhs.originalEventType {return false}
    if lhs.epochNumber != rhs.epochNumber {return false}
    if lhs.height != rhs.height {return false}
    if lhs.txID != rhs.txID {return false}
    if lhs.msgID != rhs.msgID {return false}
    if lhs.originalAttributes != rhs.originalAttributes {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_EventSlashThreshold: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventSlashThreshold"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "slashed_voting_power"),
    2: .standard(proto: "total_voting_power"),
    3: .standard(proto: "slashed_validators"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.slashedVotingPower) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.totalVotingPower) }()
      case 3: try { try decoder.decodeRepeatedBytesField(value: &self.slashedValidators) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.slashedVotingPower != 0 {
      try visitor.visitSingularInt64Field(value: self.slashedVotingPower, fieldNumber: 1)
    }
    if self.totalVotingPower != 0 {
      try visitor.visitSingularInt64Field(value: self.totalVotingPower, fieldNumber: 2)
    }
    if !self.slashedValidators.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.slashedValidators, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_EventSlashThreshold, rhs: Babylon_Epoching_V1_EventSlashThreshold) -> Bool {
    if lhs.slashedVotingPower != rhs.slashedVotingPower {return false}
    if lhs.totalVotingPower != rhs.totalVotingPower {return false}
    if lhs.slashedValidators != rhs.slashedValidators {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_EventWrappedDelegate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventWrappedDelegate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delegator_address"),
    2: .standard(proto: "validator_address"),
    3: .same(proto: "amount"),
    4: .same(proto: "denom"),
    5: .standard(proto: "epoch_boundary"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.delegatorAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.validatorAddress) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.epochBoundary) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.delegatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.delegatorAddress, fieldNumber: 1)
    }
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddress, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 3)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 4)
    }
    if self.epochBoundary != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochBoundary, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_EventWrappedDelegate, rhs: Babylon_Epoching_V1_EventWrappedDelegate) -> Bool {
    if lhs.delegatorAddress != rhs.delegatorAddress {return false}
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.epochBoundary != rhs.epochBoundary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_EventWrappedUndelegate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventWrappedUndelegate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delegator_address"),
    2: .standard(proto: "validator_address"),
    3: .same(proto: "amount"),
    4: .same(proto: "denom"),
    5: .standard(proto: "epoch_boundary"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.delegatorAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.validatorAddress) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.epochBoundary) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.delegatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.delegatorAddress, fieldNumber: 1)
    }
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddress, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 3)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 4)
    }
    if self.epochBoundary != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochBoundary, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_EventWrappedUndelegate, rhs: Babylon_Epoching_V1_EventWrappedUndelegate) -> Bool {
    if lhs.delegatorAddress != rhs.delegatorAddress {return false}
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.epochBoundary != rhs.epochBoundary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_EventWrappedBeginRedelegate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventWrappedBeginRedelegate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delegator_address"),
    2: .standard(proto: "source_validator_address"),
    3: .standard(proto: "destination_validator_address"),
    4: .same(proto: "amount"),
    5: .same(proto: "denom"),
    6: .standard(proto: "epoch_boundary"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.delegatorAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceValidatorAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.destinationValidatorAddress) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.denom) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.epochBoundary) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.delegatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.delegatorAddress, fieldNumber: 1)
    }
    if !self.sourceValidatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceValidatorAddress, fieldNumber: 2)
    }
    if !self.destinationValidatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.destinationValidatorAddress, fieldNumber: 3)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 4)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 5)
    }
    if self.epochBoundary != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochBoundary, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_EventWrappedBeginRedelegate, rhs: Babylon_Epoching_V1_EventWrappedBeginRedelegate) -> Bool {
    if lhs.delegatorAddress != rhs.delegatorAddress {return false}
    if lhs.sourceValidatorAddress != rhs.sourceValidatorAddress {return false}
    if lhs.destinationValidatorAddress != rhs.destinationValidatorAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.epochBoundary != rhs.epochBoundary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_EventWrappedCancelUnbondingDelegation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventWrappedCancelUnbondingDelegation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delegator_address"),
    2: .standard(proto: "validator_address"),
    3: .same(proto: "amount"),
    4: .standard(proto: "creation_height"),
    5: .standard(proto: "epoch_boundary"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.delegatorAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.validatorAddress) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.amount) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.creationHeight) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.epochBoundary) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.delegatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.delegatorAddress, fieldNumber: 1)
    }
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddress, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 3)
    }
    if self.creationHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.creationHeight, fieldNumber: 4)
    }
    if self.epochBoundary != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochBoundary, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_EventWrappedCancelUnbondingDelegation, rhs: Babylon_Epoching_V1_EventWrappedCancelUnbondingDelegation) -> Bool {
    if lhs.delegatorAddress != rhs.delegatorAddress {return false}
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.creationHeight != rhs.creationHeight {return false}
    if lhs.epochBoundary != rhs.epochBoundary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_EventWrappedEditValidator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventWrappedEditValidator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "validator_address"),
    2: .standard(proto: "epoch_boundary"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.validatorAddress) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.epochBoundary) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.validatorAddress, fieldNumber: 1)
    }
    if self.epochBoundary != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochBoundary, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_EventWrappedEditValidator, rhs: Babylon_Epoching_V1_EventWrappedEditValidator) -> Bool {
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs.epochBoundary != rhs.epochBoundary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Babylon_Epoching_V1_EventWrappedStakingUpdateParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventWrappedStakingUpdateParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "unbonding_time"),
    2: .standard(proto: "max_validators"),
    3: .standard(proto: "max_entries"),
    4: .standard(proto: "historical_entries"),
    5: .standard(proto: "bond_denom"),
    6: .standard(proto: "min_commission_rate"),
    7: .standard(proto: "epoch_boundary"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.unbondingTime) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.maxValidators) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.maxEntries) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.historicalEntries) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.bondDenom) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.minCommissionRate) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.epochBoundary) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.unbondingTime.isEmpty {
      try visitor.visitSingularStringField(value: self.unbondingTime, fieldNumber: 1)
    }
    if self.maxValidators != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxValidators, fieldNumber: 2)
    }
    if self.maxEntries != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxEntries, fieldNumber: 3)
    }
    if self.historicalEntries != 0 {
      try visitor.visitSingularUInt32Field(value: self.historicalEntries, fieldNumber: 4)
    }
    if !self.bondDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.bondDenom, fieldNumber: 5)
    }
    if !self.minCommissionRate.isEmpty {
      try visitor.visitSingularStringField(value: self.minCommissionRate, fieldNumber: 6)
    }
    if self.epochBoundary != 0 {
      try visitor.visitSingularUInt64Field(value: self.epochBoundary, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Babylon_Epoching_V1_EventWrappedStakingUpdateParams, rhs: Babylon_Epoching_V1_EventWrappedStakingUpdateParams) -> Bool {
    if lhs.unbondingTime != rhs.unbondingTime {return false}
    if lhs.maxValidators != rhs.maxValidators {return false}
    if lhs.maxEntries != rhs.maxEntries {return false}
    if lhs.historicalEntries != rhs.historicalEntries {return false}
    if lhs.bondDenom != rhs.bondDenom {return false}
    if lhs.minCommissionRate != rhs.minCommissionRate {return false}
    if lhs.epochBoundary != rhs.epochBoundary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
