// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: tendermint/abci/types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Tendermint_Abci_CheckTxType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case new // = 0
  case recheck // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .new
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .new
    case 1: self = .recheck
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .new: return 0
    case .recheck: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tendermint_Abci_CheckTxType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Tendermint_Abci_CheckTxType] = [
    .new,
    .recheck,
  ]
}

#endif  // swift(>=4.2)

enum Tendermint_Abci_MisbehaviorType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case duplicateVote // = 1
  case lightClientAttack // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .duplicateVote
    case 2: self = .lightClientAttack
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .duplicateVote: return 1
    case .lightClientAttack: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Tendermint_Abci_MisbehaviorType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Tendermint_Abci_MisbehaviorType] = [
    .unknown,
    .duplicateVote,
    .lightClientAttack,
  ]
}

#endif  // swift(>=4.2)

struct Tendermint_Abci_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Tendermint_Abci_Request.OneOf_Value? = nil

  var echo: Tendermint_Abci_RequestEcho {
    get {
      if case .echo(let v)? = value {return v}
      return Tendermint_Abci_RequestEcho()
    }
    set {value = .echo(newValue)}
  }

  var flush: Tendermint_Abci_RequestFlush {
    get {
      if case .flush(let v)? = value {return v}
      return Tendermint_Abci_RequestFlush()
    }
    set {value = .flush(newValue)}
  }

  var info: Tendermint_Abci_RequestInfo {
    get {
      if case .info(let v)? = value {return v}
      return Tendermint_Abci_RequestInfo()
    }
    set {value = .info(newValue)}
  }

  var initChain: Tendermint_Abci_RequestInitChain {
    get {
      if case .initChain(let v)? = value {return v}
      return Tendermint_Abci_RequestInitChain()
    }
    set {value = .initChain(newValue)}
  }

  var query: Tendermint_Abci_RequestQuery {
    get {
      if case .query(let v)? = value {return v}
      return Tendermint_Abci_RequestQuery()
    }
    set {value = .query(newValue)}
  }

  var checkTx: Tendermint_Abci_RequestCheckTx {
    get {
      if case .checkTx(let v)? = value {return v}
      return Tendermint_Abci_RequestCheckTx()
    }
    set {value = .checkTx(newValue)}
  }

  var commit: Tendermint_Abci_RequestCommit {
    get {
      if case .commit(let v)? = value {return v}
      return Tendermint_Abci_RequestCommit()
    }
    set {value = .commit(newValue)}
  }

  var listSnapshots: Tendermint_Abci_RequestListSnapshots {
    get {
      if case .listSnapshots(let v)? = value {return v}
      return Tendermint_Abci_RequestListSnapshots()
    }
    set {value = .listSnapshots(newValue)}
  }

  var offerSnapshot: Tendermint_Abci_RequestOfferSnapshot {
    get {
      if case .offerSnapshot(let v)? = value {return v}
      return Tendermint_Abci_RequestOfferSnapshot()
    }
    set {value = .offerSnapshot(newValue)}
  }

  var loadSnapshotChunk: Tendermint_Abci_RequestLoadSnapshotChunk {
    get {
      if case .loadSnapshotChunk(let v)? = value {return v}
      return Tendermint_Abci_RequestLoadSnapshotChunk()
    }
    set {value = .loadSnapshotChunk(newValue)}
  }

  var applySnapshotChunk: Tendermint_Abci_RequestApplySnapshotChunk {
    get {
      if case .applySnapshotChunk(let v)? = value {return v}
      return Tendermint_Abci_RequestApplySnapshotChunk()
    }
    set {value = .applySnapshotChunk(newValue)}
  }

  var prepareProposal: Tendermint_Abci_RequestPrepareProposal {
    get {
      if case .prepareProposal(let v)? = value {return v}
      return Tendermint_Abci_RequestPrepareProposal()
    }
    set {value = .prepareProposal(newValue)}
  }

  var processProposal: Tendermint_Abci_RequestProcessProposal {
    get {
      if case .processProposal(let v)? = value {return v}
      return Tendermint_Abci_RequestProcessProposal()
    }
    set {value = .processProposal(newValue)}
  }

  var extendVote: Tendermint_Abci_RequestExtendVote {
    get {
      if case .extendVote(let v)? = value {return v}
      return Tendermint_Abci_RequestExtendVote()
    }
    set {value = .extendVote(newValue)}
  }

  var verifyVoteExtension: Tendermint_Abci_RequestVerifyVoteExtension {
    get {
      if case .verifyVoteExtension(let v)? = value {return v}
      return Tendermint_Abci_RequestVerifyVoteExtension()
    }
    set {value = .verifyVoteExtension(newValue)}
  }

  var finalizeBlock: Tendermint_Abci_RequestFinalizeBlock {
    get {
      if case .finalizeBlock(let v)? = value {return v}
      return Tendermint_Abci_RequestFinalizeBlock()
    }
    set {value = .finalizeBlock(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case echo(Tendermint_Abci_RequestEcho)
    case flush(Tendermint_Abci_RequestFlush)
    case info(Tendermint_Abci_RequestInfo)
    case initChain(Tendermint_Abci_RequestInitChain)
    case query(Tendermint_Abci_RequestQuery)
    case checkTx(Tendermint_Abci_RequestCheckTx)
    case commit(Tendermint_Abci_RequestCommit)
    case listSnapshots(Tendermint_Abci_RequestListSnapshots)
    case offerSnapshot(Tendermint_Abci_RequestOfferSnapshot)
    case loadSnapshotChunk(Tendermint_Abci_RequestLoadSnapshotChunk)
    case applySnapshotChunk(Tendermint_Abci_RequestApplySnapshotChunk)
    case prepareProposal(Tendermint_Abci_RequestPrepareProposal)
    case processProposal(Tendermint_Abci_RequestProcessProposal)
    case extendVote(Tendermint_Abci_RequestExtendVote)
    case verifyVoteExtension(Tendermint_Abci_RequestVerifyVoteExtension)
    case finalizeBlock(Tendermint_Abci_RequestFinalizeBlock)

  #if !swift(>=4.1)
    static func ==(lhs: Tendermint_Abci_Request.OneOf_Value, rhs: Tendermint_Abci_Request.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.echo, .echo): return {
        guard case .echo(let l) = lhs, case .echo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.flush, .flush): return {
        guard case .flush(let l) = lhs, case .flush(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.info, .info): return {
        guard case .info(let l) = lhs, case .info(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.initChain, .initChain): return {
        guard case .initChain(let l) = lhs, case .initChain(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.query, .query): return {
        guard case .query(let l) = lhs, case .query(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.checkTx, .checkTx): return {
        guard case .checkTx(let l) = lhs, case .checkTx(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.commit, .commit): return {
        guard case .commit(let l) = lhs, case .commit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.listSnapshots, .listSnapshots): return {
        guard case .listSnapshots(let l) = lhs, case .listSnapshots(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.offerSnapshot, .offerSnapshot): return {
        guard case .offerSnapshot(let l) = lhs, case .offerSnapshot(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadSnapshotChunk, .loadSnapshotChunk): return {
        guard case .loadSnapshotChunk(let l) = lhs, case .loadSnapshotChunk(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.applySnapshotChunk, .applySnapshotChunk): return {
        guard case .applySnapshotChunk(let l) = lhs, case .applySnapshotChunk(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.prepareProposal, .prepareProposal): return {
        guard case .prepareProposal(let l) = lhs, case .prepareProposal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.processProposal, .processProposal): return {
        guard case .processProposal(let l) = lhs, case .processProposal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.extendVote, .extendVote): return {
        guard case .extendVote(let l) = lhs, case .extendVote(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.verifyVoteExtension, .verifyVoteExtension): return {
        guard case .verifyVoteExtension(let l) = lhs, case .verifyVoteExtension(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.finalizeBlock, .finalizeBlock): return {
        guard case .finalizeBlock(let l) = lhs, case .finalizeBlock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Tendermint_Abci_RequestEcho {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_RequestFlush {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_RequestInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: String = String()

  var blockVersion: UInt64 = 0

  var p2PVersion: UInt64 = 0

  var abciVersion: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_RequestInitChain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var chainID: String = String()

  var consensusParams: Tendermint_Types_ConsensusParams {
    get {return _consensusParams ?? Tendermint_Types_ConsensusParams()}
    set {_consensusParams = newValue}
  }
  /// Returns true if `consensusParams` has been explicitly set.
  var hasConsensusParams: Bool {return self._consensusParams != nil}
  /// Clears the value of `consensusParams`. Subsequent reads from it will return its default value.
  mutating func clearConsensusParams() {self._consensusParams = nil}

  var validators: [Tendermint_Abci_ValidatorUpdate] = []

  var appStateBytes: Data = Data()

  var initialHeight: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _consensusParams: Tendermint_Types_ConsensusParams? = nil
}

struct Tendermint_Abci_RequestQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = Data()

  var path: String = String()

  var height: Int64 = 0

  var prove: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_RequestCheckTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tx: Data = Data()

  var type: Tendermint_Abci_CheckTxType = .new

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_RequestCommit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// lists available snapshots
struct Tendermint_Abci_RequestListSnapshots {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// offers a snapshot to the application
struct Tendermint_Abci_RequestOfferSnapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// snapshot offered by peers
  var snapshot: Tendermint_Abci_Snapshot {
    get {return _snapshot ?? Tendermint_Abci_Snapshot()}
    set {_snapshot = newValue}
  }
  /// Returns true if `snapshot` has been explicitly set.
  var hasSnapshot: Bool {return self._snapshot != nil}
  /// Clears the value of `snapshot`. Subsequent reads from it will return its default value.
  mutating func clearSnapshot() {self._snapshot = nil}

  /// light client-verified app hash for snapshot height
  var appHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _snapshot: Tendermint_Abci_Snapshot? = nil
}

/// loads a snapshot chunk
struct Tendermint_Abci_RequestLoadSnapshotChunk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var height: UInt64 = 0

  var format: UInt32 = 0

  var chunk: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Applies a snapshot chunk
struct Tendermint_Abci_RequestApplySnapshotChunk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var index: UInt32 = 0

  var chunk: Data = Data()

  var sender: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_RequestPrepareProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the modified transactions cannot exceed this size.
  var maxTxBytes: Int64 = 0

  /// txs is an array of transactions that will be included in a block,
  /// sent to the app for possible modifications.
  var txs: [Data] = []

  var localLastCommit: Tendermint_Abci_ExtendedCommitInfo {
    get {return _localLastCommit ?? Tendermint_Abci_ExtendedCommitInfo()}
    set {_localLastCommit = newValue}
  }
  /// Returns true if `localLastCommit` has been explicitly set.
  var hasLocalLastCommit: Bool {return self._localLastCommit != nil}
  /// Clears the value of `localLastCommit`. Subsequent reads from it will return its default value.
  mutating func clearLocalLastCommit() {self._localLastCommit = nil}

  var misbehavior: [Tendermint_Abci_Misbehavior] = []

  var height: Int64 = 0

  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var nextValidatorsHash: Data = Data()

  /// address of the public key of the validator proposing the block.
  var proposerAddress: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _localLastCommit: Tendermint_Abci_ExtendedCommitInfo? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Tendermint_Abci_RequestProcessProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txs: [Data] = []

  var proposedLastCommit: Tendermint_Abci_CommitInfo {
    get {return _proposedLastCommit ?? Tendermint_Abci_CommitInfo()}
    set {_proposedLastCommit = newValue}
  }
  /// Returns true if `proposedLastCommit` has been explicitly set.
  var hasProposedLastCommit: Bool {return self._proposedLastCommit != nil}
  /// Clears the value of `proposedLastCommit`. Subsequent reads from it will return its default value.
  mutating func clearProposedLastCommit() {self._proposedLastCommit = nil}

  var misbehavior: [Tendermint_Abci_Misbehavior] = []

  /// hash is the merkle root hash of the fields of the proposed block.
  var hash: Data = Data()

  var height: Int64 = 0

  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var nextValidatorsHash: Data = Data()

  /// address of the public key of the original proposer of the block.
  var proposerAddress: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _proposedLastCommit: Tendermint_Abci_CommitInfo? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Extends a vote with application-injected data
struct Tendermint_Abci_RequestExtendVote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the hash of the block  that this vote may be referring to
  var hash: Data = Data()

  /// the height of the extended vote
  var height: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Verify the vote extension
struct Tendermint_Abci_RequestVerifyVoteExtension {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the hash of the block that this received vote corresponds to
  var hash: Data = Data()

  /// the validator that signed the vote extension
  var validatorAddress: Data = Data()

  var height: Int64 = 0

  var voteExtension: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_RequestFinalizeBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txs: [Data] = []

  var decidedLastCommit: Tendermint_Abci_CommitInfo {
    get {return _decidedLastCommit ?? Tendermint_Abci_CommitInfo()}
    set {_decidedLastCommit = newValue}
  }
  /// Returns true if `decidedLastCommit` has been explicitly set.
  var hasDecidedLastCommit: Bool {return self._decidedLastCommit != nil}
  /// Clears the value of `decidedLastCommit`. Subsequent reads from it will return its default value.
  mutating func clearDecidedLastCommit() {self._decidedLastCommit = nil}

  var misbehavior: [Tendermint_Abci_Misbehavior] = []

  /// hash is the merkle root hash of the fields of the decided block.
  var hash: Data = Data()

  var height: Int64 = 0

  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var nextValidatorsHash: Data = Data()

  /// proposer_address is the address of the public key of the original proposer of the block.
  var proposerAddress: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _decidedLastCommit: Tendermint_Abci_CommitInfo? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Tendermint_Abci_Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var value: Tendermint_Abci_Response.OneOf_Value? = nil

  var exception: Tendermint_Abci_ResponseException {
    get {
      if case .exception(let v)? = value {return v}
      return Tendermint_Abci_ResponseException()
    }
    set {value = .exception(newValue)}
  }

  var echo: Tendermint_Abci_ResponseEcho {
    get {
      if case .echo(let v)? = value {return v}
      return Tendermint_Abci_ResponseEcho()
    }
    set {value = .echo(newValue)}
  }

  var flush: Tendermint_Abci_ResponseFlush {
    get {
      if case .flush(let v)? = value {return v}
      return Tendermint_Abci_ResponseFlush()
    }
    set {value = .flush(newValue)}
  }

  var info: Tendermint_Abci_ResponseInfo {
    get {
      if case .info(let v)? = value {return v}
      return Tendermint_Abci_ResponseInfo()
    }
    set {value = .info(newValue)}
  }

  var initChain: Tendermint_Abci_ResponseInitChain {
    get {
      if case .initChain(let v)? = value {return v}
      return Tendermint_Abci_ResponseInitChain()
    }
    set {value = .initChain(newValue)}
  }

  var query: Tendermint_Abci_ResponseQuery {
    get {
      if case .query(let v)? = value {return v}
      return Tendermint_Abci_ResponseQuery()
    }
    set {value = .query(newValue)}
  }

  var checkTx: Tendermint_Abci_ResponseCheckTx {
    get {
      if case .checkTx(let v)? = value {return v}
      return Tendermint_Abci_ResponseCheckTx()
    }
    set {value = .checkTx(newValue)}
  }

  var deliverTx: Tendermint_Abci_ResponseDeliverTx {
    get {
      if case .deliverTx(let v)? = value {return v}
      return Tendermint_Abci_ResponseDeliverTx()
    }
    set {value = .deliverTx(newValue)}
  }

  var commit: Tendermint_Abci_ResponseCommit {
    get {
      if case .commit(let v)? = value {return v}
      return Tendermint_Abci_ResponseCommit()
    }
    set {value = .commit(newValue)}
  }

  var listSnapshots: Tendermint_Abci_ResponseListSnapshots {
    get {
      if case .listSnapshots(let v)? = value {return v}
      return Tendermint_Abci_ResponseListSnapshots()
    }
    set {value = .listSnapshots(newValue)}
  }

  var offerSnapshot: Tendermint_Abci_ResponseOfferSnapshot {
    get {
      if case .offerSnapshot(let v)? = value {return v}
      return Tendermint_Abci_ResponseOfferSnapshot()
    }
    set {value = .offerSnapshot(newValue)}
  }

  var loadSnapshotChunk: Tendermint_Abci_ResponseLoadSnapshotChunk {
    get {
      if case .loadSnapshotChunk(let v)? = value {return v}
      return Tendermint_Abci_ResponseLoadSnapshotChunk()
    }
    set {value = .loadSnapshotChunk(newValue)}
  }

  var applySnapshotChunk: Tendermint_Abci_ResponseApplySnapshotChunk {
    get {
      if case .applySnapshotChunk(let v)? = value {return v}
      return Tendermint_Abci_ResponseApplySnapshotChunk()
    }
    set {value = .applySnapshotChunk(newValue)}
  }

  var prepareProposal: Tendermint_Abci_ResponsePrepareProposal {
    get {
      if case .prepareProposal(let v)? = value {return v}
      return Tendermint_Abci_ResponsePrepareProposal()
    }
    set {value = .prepareProposal(newValue)}
  }

  var processProposal: Tendermint_Abci_ResponseProcessProposal {
    get {
      if case .processProposal(let v)? = value {return v}
      return Tendermint_Abci_ResponseProcessProposal()
    }
    set {value = .processProposal(newValue)}
  }

  var extendVote: Tendermint_Abci_ResponseExtendVote {
    get {
      if case .extendVote(let v)? = value {return v}
      return Tendermint_Abci_ResponseExtendVote()
    }
    set {value = .extendVote(newValue)}
  }

  var verifyVoteExtension: Tendermint_Abci_ResponseVerifyVoteExtension {
    get {
      if case .verifyVoteExtension(let v)? = value {return v}
      return Tendermint_Abci_ResponseVerifyVoteExtension()
    }
    set {value = .verifyVoteExtension(newValue)}
  }

  var finalizeBlock: Tendermint_Abci_ResponseFinalizeBlock {
    get {
      if case .finalizeBlock(let v)? = value {return v}
      return Tendermint_Abci_ResponseFinalizeBlock()
    }
    set {value = .finalizeBlock(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Value: Equatable {
    case exception(Tendermint_Abci_ResponseException)
    case echo(Tendermint_Abci_ResponseEcho)
    case flush(Tendermint_Abci_ResponseFlush)
    case info(Tendermint_Abci_ResponseInfo)
    case initChain(Tendermint_Abci_ResponseInitChain)
    case query(Tendermint_Abci_ResponseQuery)
    case checkTx(Tendermint_Abci_ResponseCheckTx)
    case deliverTx(Tendermint_Abci_ResponseDeliverTx)
    case commit(Tendermint_Abci_ResponseCommit)
    case listSnapshots(Tendermint_Abci_ResponseListSnapshots)
    case offerSnapshot(Tendermint_Abci_ResponseOfferSnapshot)
    case loadSnapshotChunk(Tendermint_Abci_ResponseLoadSnapshotChunk)
    case applySnapshotChunk(Tendermint_Abci_ResponseApplySnapshotChunk)
    case prepareProposal(Tendermint_Abci_ResponsePrepareProposal)
    case processProposal(Tendermint_Abci_ResponseProcessProposal)
    case extendVote(Tendermint_Abci_ResponseExtendVote)
    case verifyVoteExtension(Tendermint_Abci_ResponseVerifyVoteExtension)
    case finalizeBlock(Tendermint_Abci_ResponseFinalizeBlock)

  #if !swift(>=4.1)
    static func ==(lhs: Tendermint_Abci_Response.OneOf_Value, rhs: Tendermint_Abci_Response.OneOf_Value) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.exception, .exception): return {
        guard case .exception(let l) = lhs, case .exception(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.echo, .echo): return {
        guard case .echo(let l) = lhs, case .echo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.flush, .flush): return {
        guard case .flush(let l) = lhs, case .flush(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.info, .info): return {
        guard case .info(let l) = lhs, case .info(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.initChain, .initChain): return {
        guard case .initChain(let l) = lhs, case .initChain(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.query, .query): return {
        guard case .query(let l) = lhs, case .query(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.checkTx, .checkTx): return {
        guard case .checkTx(let l) = lhs, case .checkTx(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deliverTx, .deliverTx): return {
        guard case .deliverTx(let l) = lhs, case .deliverTx(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.commit, .commit): return {
        guard case .commit(let l) = lhs, case .commit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.listSnapshots, .listSnapshots): return {
        guard case .listSnapshots(let l) = lhs, case .listSnapshots(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.offerSnapshot, .offerSnapshot): return {
        guard case .offerSnapshot(let l) = lhs, case .offerSnapshot(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.loadSnapshotChunk, .loadSnapshotChunk): return {
        guard case .loadSnapshotChunk(let l) = lhs, case .loadSnapshotChunk(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.applySnapshotChunk, .applySnapshotChunk): return {
        guard case .applySnapshotChunk(let l) = lhs, case .applySnapshotChunk(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.prepareProposal, .prepareProposal): return {
        guard case .prepareProposal(let l) = lhs, case .prepareProposal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.processProposal, .processProposal): return {
        guard case .processProposal(let l) = lhs, case .processProposal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.extendVote, .extendVote): return {
        guard case .extendVote(let l) = lhs, case .extendVote(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.verifyVoteExtension, .verifyVoteExtension): return {
        guard case .verifyVoteExtension(let l) = lhs, case .verifyVoteExtension(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.finalizeBlock, .finalizeBlock): return {
        guard case .finalizeBlock(let l) = lhs, case .finalizeBlock(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// nondeterministic
struct Tendermint_Abci_ResponseException {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var error: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseEcho {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseFlush {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: String = String()

  var version: String = String()

  var appVersion: UInt64 = 0

  var lastBlockHeight: Int64 = 0

  var lastBlockAppHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseInitChain {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var consensusParams: Tendermint_Types_ConsensusParams {
    get {return _consensusParams ?? Tendermint_Types_ConsensusParams()}
    set {_consensusParams = newValue}
  }
  /// Returns true if `consensusParams` has been explicitly set.
  var hasConsensusParams: Bool {return self._consensusParams != nil}
  /// Clears the value of `consensusParams`. Subsequent reads from it will return its default value.
  mutating func clearConsensusParams() {self._consensusParams = nil}

  var validators: [Tendermint_Abci_ValidatorUpdate] = []

  var appHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _consensusParams: Tendermint_Types_ConsensusParams? = nil
}

struct Tendermint_Abci_ResponseQuery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: UInt32 = 0

  /// bytes data = 2; // use "value" instead.
  var log: String = String()

  /// nondeterministic
  var info: String = String()

  var index: Int64 = 0

  var key: Data = Data()

  var value: Data = Data()

  var proofOps: Tendermint_Crypto_ProofOps {
    get {return _proofOps ?? Tendermint_Crypto_ProofOps()}
    set {_proofOps = newValue}
  }
  /// Returns true if `proofOps` has been explicitly set.
  var hasProofOps: Bool {return self._proofOps != nil}
  /// Clears the value of `proofOps`. Subsequent reads from it will return its default value.
  mutating func clearProofOps() {self._proofOps = nil}

  var height: Int64 = 0

  var codespace: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _proofOps: Tendermint_Crypto_ProofOps? = nil
}

struct Tendermint_Abci_ResponseCheckTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: UInt32 = 0

  var data: Data = Data()

  /// nondeterministic
  var log: String = String()

  /// nondeterministic
  var info: String = String()

  var gasWanted: Int64 = 0

  var gasUsed: Int64 = 0

  var events: [Tendermint_Abci_Event] = []

  var codespace: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseDeliverTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: UInt32 = 0

  var data: Data = Data()

  /// nondeterministic
  var log: String = String()

  /// nondeterministic
  var info: String = String()

  var gasWanted: Int64 = 0

  var gasUsed: Int64 = 0

  /// nondeterministic
  var events: [Tendermint_Abci_Event] = []

  var codespace: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseCommit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var retainHeight: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseListSnapshots {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var snapshots: [Tendermint_Abci_Snapshot] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseOfferSnapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Tendermint_Abci_ResponseOfferSnapshot.Result = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unknown result, abort all snapshot restoration
    case unknown // = 0

    /// Snapshot accepted, apply chunks
    case accept // = 1

    /// Abort all snapshot restoration
    case abort // = 2

    /// Reject this specific snapshot, try others
    case reject // = 3

    /// Reject all snapshots of this format, try others
    case rejectFormat // = 4

    /// Reject all snapshots from the sender(s), try others
    case rejectSender // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .accept
      case 2: self = .abort
      case 3: self = .reject
      case 4: self = .rejectFormat
      case 5: self = .rejectSender
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .accept: return 1
      case .abort: return 2
      case .reject: return 3
      case .rejectFormat: return 4
      case .rejectSender: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Tendermint_Abci_ResponseOfferSnapshot.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Tendermint_Abci_ResponseOfferSnapshot.Result] = [
    .unknown,
    .accept,
    .abort,
    .reject,
    .rejectFormat,
    .rejectSender,
  ]
}

#endif  // swift(>=4.2)

struct Tendermint_Abci_ResponseLoadSnapshotChunk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chunk: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseApplySnapshotChunk {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: Tendermint_Abci_ResponseApplySnapshotChunk.Result = .unknown

  /// Chunks to refetch and reapply
  var refetchChunks: [UInt32] = []

  /// Chunk senders to reject and ban
  var rejectSenders: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unknown result, abort all snapshot restoration
    case unknown // = 0

    /// Chunk successfully accepted
    case accept // = 1

    /// Abort all snapshot restoration
    case abort // = 2

    /// Retry chunk (combine with refetch and reject)
    case retry // = 3

    /// Retry snapshot (combine with refetch and reject)
    case retrySnapshot // = 4

    /// Reject this snapshot, try others
    case rejectSnapshot // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .accept
      case 2: self = .abort
      case 3: self = .retry
      case 4: self = .retrySnapshot
      case 5: self = .rejectSnapshot
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .accept: return 1
      case .abort: return 2
      case .retry: return 3
      case .retrySnapshot: return 4
      case .rejectSnapshot: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Tendermint_Abci_ResponseApplySnapshotChunk.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Tendermint_Abci_ResponseApplySnapshotChunk.Result] = [
    .unknown,
    .accept,
    .abort,
    .retry,
    .retrySnapshot,
    .rejectSnapshot,
  ]
}

#endif  // swift(>=4.2)

struct Tendermint_Abci_ResponsePrepareProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var txs: [Data] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseProcessProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Tendermint_Abci_ResponseProcessProposal.ProposalStatus = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ProposalStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case accept // = 1
    case reject // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .accept
      case 2: self = .reject
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .accept: return 1
      case .reject: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Tendermint_Abci_ResponseProcessProposal.ProposalStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Tendermint_Abci_ResponseProcessProposal.ProposalStatus] = [
    .unknown,
    .accept,
    .reject,
  ]
}

#endif  // swift(>=4.2)

struct Tendermint_Abci_ResponseExtendVote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var voteExtension: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ResponseVerifyVoteExtension {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: Tendermint_Abci_ResponseVerifyVoteExtension.VerifyStatus = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum VerifyStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case accept // = 1

    /// Rejecting the vote extension will reject the entire precommit by the sender.
    /// Incorrectly implementing this thus has liveness implications as it may affect
    /// CometBFT's ability to receive 2/3+ valid votes to finalize the block.
    /// Honest nodes should never be rejected.
    case reject // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .accept
      case 2: self = .reject
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .accept: return 1
      case .reject: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Tendermint_Abci_ResponseVerifyVoteExtension.VerifyStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Tendermint_Abci_ResponseVerifyVoteExtension.VerifyStatus] = [
    .unknown,
    .accept,
    .reject,
  ]
}

#endif  // swift(>=4.2)

struct Tendermint_Abci_ResponseFinalizeBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// set of block events emmitted as part of executing the block
  var events: [Tendermint_Abci_Event] = []

  /// the result of executing each transaction including the events
  /// the particular transction emitted. This should match the order
  /// of the transactions delivered in the block itself
  var txResults: [Tendermint_Abci_ExecTxResult] = []

  /// a list of updates to the validator set. These will reflect the validator set at current height + 2.
  var validatorUpdates: [Tendermint_Abci_ValidatorUpdate] = []

  /// updates to the consensus params, if any.
  var consensusParamUpdates: Tendermint_Types_ConsensusParams {
    get {return _consensusParamUpdates ?? Tendermint_Types_ConsensusParams()}
    set {_consensusParamUpdates = newValue}
  }
  /// Returns true if `consensusParamUpdates` has been explicitly set.
  var hasConsensusParamUpdates: Bool {return self._consensusParamUpdates != nil}
  /// Clears the value of `consensusParamUpdates`. Subsequent reads from it will return its default value.
  mutating func clearConsensusParamUpdates() {self._consensusParamUpdates = nil}

  /// app_hash is the hash of the applications' state which is used to confirm that execution of the transactions was deterministic. It is up to the application to decide which algorithm to use.
  var appHash: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _consensusParamUpdates: Tendermint_Types_ConsensusParams? = nil
}

struct Tendermint_Abci_CommitInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var round: Int32 = 0

  var votes: [Tendermint_Abci_VoteInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ExtendedCommitInfo is similar to CommitInfo except that it is only used in
/// the PrepareProposal request such that CometBFT can provide vote extensions
/// to the application.
struct Tendermint_Abci_ExtendedCommitInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The round at which the block proposer decided in the previous height.
  var round: Int32 = 0

  /// List of validators' addresses in the last validator set with their voting
  /// information, including vote extensions.
  var votes: [Tendermint_Abci_ExtendedVoteInfo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Event allows application developers to attach additional information to
/// ResponseFinalizeBlock and ResponseCheckTx.
/// Later, transactions may be queried using these events.
struct Tendermint_Abci_Event {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var attributes: [Tendermint_Abci_EventAttribute] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EventAttribute is a single key-value pair, associated with an event.
struct Tendermint_Abci_EventAttribute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var value: String = String()

  /// nondeterministic
  var index: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ExecTxResult contains results of executing one individual transaction.
///
/// * Its structure is equivalent to #ResponseDeliverTx which will be deprecated/deleted
struct Tendermint_Abci_ExecTxResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: UInt32 = 0

  var data: Data = Data()

  /// nondeterministic
  var log: String = String()

  /// nondeterministic
  var info: String = String()

  var gasWanted: Int64 = 0

  var gasUsed: Int64 = 0

  /// nondeterministic
  var events: [Tendermint_Abci_Event] = []

  var codespace: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// TxResult contains results of executing the transaction.
///
/// One usage is indexing transaction results.
struct Tendermint_Abci_TxResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var height: Int64 = 0

  var index: UInt32 = 0

  var tx: Data = Data()

  var result: Tendermint_Abci_ExecTxResult {
    get {return _result ?? Tendermint_Abci_ExecTxResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {self._result = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _result: Tendermint_Abci_ExecTxResult? = nil
}

struct Tendermint_Abci_Validator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The first 20 bytes of SHA256(public key)
  var address: Data = Data()

  /// PubKey pub_key = 2 [(gogoproto.nullable)=false];
  var power: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Tendermint_Abci_ValidatorUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pubKey: Tendermint_Crypto_PublicKey {
    get {return _pubKey ?? Tendermint_Crypto_PublicKey()}
    set {_pubKey = newValue}
  }
  /// Returns true if `pubKey` has been explicitly set.
  var hasPubKey: Bool {return self._pubKey != nil}
  /// Clears the value of `pubKey`. Subsequent reads from it will return its default value.
  mutating func clearPubKey() {self._pubKey = nil}

  var power: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pubKey: Tendermint_Crypto_PublicKey? = nil
}

struct Tendermint_Abci_VoteInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var validator: Tendermint_Abci_Validator {
    get {return _validator ?? Tendermint_Abci_Validator()}
    set {_validator = newValue}
  }
  /// Returns true if `validator` has been explicitly set.
  var hasValidator: Bool {return self._validator != nil}
  /// Clears the value of `validator`. Subsequent reads from it will return its default value.
  mutating func clearValidator() {self._validator = nil}

  var blockIDFlag: Tendermint_Types_BlockIDFlag = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _validator: Tendermint_Abci_Validator? = nil
}

struct Tendermint_Abci_ExtendedVoteInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The validator that sent the vote.
  var validator: Tendermint_Abci_Validator {
    get {return _validator ?? Tendermint_Abci_Validator()}
    set {_validator = newValue}
  }
  /// Returns true if `validator` has been explicitly set.
  var hasValidator: Bool {return self._validator != nil}
  /// Clears the value of `validator`. Subsequent reads from it will return its default value.
  mutating func clearValidator() {self._validator = nil}

  /// Non-deterministic extension provided by the sending validator's application.
  var voteExtension: Data = Data()

  /// Vote extension signature created by CometBFT
  var extensionSignature: Data = Data()

  /// block_id_flag indicates whether the validator voted for a block, nil, or did not vote at all
  var blockIDFlag: Tendermint_Types_BlockIDFlag = .unknown

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _validator: Tendermint_Abci_Validator? = nil
}

struct Tendermint_Abci_Misbehavior {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Tendermint_Abci_MisbehaviorType = .unknown

  /// The offending validator
  var validator: Tendermint_Abci_Validator {
    get {return _validator ?? Tendermint_Abci_Validator()}
    set {_validator = newValue}
  }
  /// Returns true if `validator` has been explicitly set.
  var hasValidator: Bool {return self._validator != nil}
  /// Clears the value of `validator`. Subsequent reads from it will return its default value.
  mutating func clearValidator() {self._validator = nil}

  /// The height when the offense occurred
  var height: Int64 = 0

  /// The corresponding time where the offense occurred
  var time: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _time ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  /// Total voting power of the validator set in case the ABCI application does
  /// not store historical validators.
  /// https://github.com/tendermint/tendermint/issues/4581
  var totalVotingPower: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _validator: Tendermint_Abci_Validator? = nil
  fileprivate var _time: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Tendermint_Abci_Snapshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The height at which the snapshot was taken
  var height: UInt64 = 0

  /// The application-specific snapshot format
  var format: UInt32 = 0

  /// Number of chunks in the snapshot
  var chunks: UInt32 = 0

  /// Arbitrary snapshot hash, equal only if identical
  var hash: Data = Data()

  /// Arbitrary application metadata
  var metadata: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Tendermint_Abci_CheckTxType: @unchecked Sendable {}
extension Tendermint_Abci_MisbehaviorType: @unchecked Sendable {}
extension Tendermint_Abci_Request: @unchecked Sendable {}
extension Tendermint_Abci_Request.OneOf_Value: @unchecked Sendable {}
extension Tendermint_Abci_RequestEcho: @unchecked Sendable {}
extension Tendermint_Abci_RequestFlush: @unchecked Sendable {}
extension Tendermint_Abci_RequestInfo: @unchecked Sendable {}
extension Tendermint_Abci_RequestInitChain: @unchecked Sendable {}
extension Tendermint_Abci_RequestQuery: @unchecked Sendable {}
extension Tendermint_Abci_RequestCheckTx: @unchecked Sendable {}
extension Tendermint_Abci_RequestCommit: @unchecked Sendable {}
extension Tendermint_Abci_RequestListSnapshots: @unchecked Sendable {}
extension Tendermint_Abci_RequestOfferSnapshot: @unchecked Sendable {}
extension Tendermint_Abci_RequestLoadSnapshotChunk: @unchecked Sendable {}
extension Tendermint_Abci_RequestApplySnapshotChunk: @unchecked Sendable {}
extension Tendermint_Abci_RequestPrepareProposal: @unchecked Sendable {}
extension Tendermint_Abci_RequestProcessProposal: @unchecked Sendable {}
extension Tendermint_Abci_RequestExtendVote: @unchecked Sendable {}
extension Tendermint_Abci_RequestVerifyVoteExtension: @unchecked Sendable {}
extension Tendermint_Abci_RequestFinalizeBlock: @unchecked Sendable {}
extension Tendermint_Abci_Response: @unchecked Sendable {}
extension Tendermint_Abci_Response.OneOf_Value: @unchecked Sendable {}
extension Tendermint_Abci_ResponseException: @unchecked Sendable {}
extension Tendermint_Abci_ResponseEcho: @unchecked Sendable {}
extension Tendermint_Abci_ResponseFlush: @unchecked Sendable {}
extension Tendermint_Abci_ResponseInfo: @unchecked Sendable {}
extension Tendermint_Abci_ResponseInitChain: @unchecked Sendable {}
extension Tendermint_Abci_ResponseQuery: @unchecked Sendable {}
extension Tendermint_Abci_ResponseCheckTx: @unchecked Sendable {}
extension Tendermint_Abci_ResponseDeliverTx: @unchecked Sendable {}
extension Tendermint_Abci_ResponseCommit: @unchecked Sendable {}
extension Tendermint_Abci_ResponseListSnapshots: @unchecked Sendable {}
extension Tendermint_Abci_ResponseOfferSnapshot: @unchecked Sendable {}
extension Tendermint_Abci_ResponseOfferSnapshot.Result: @unchecked Sendable {}
extension Tendermint_Abci_ResponseLoadSnapshotChunk: @unchecked Sendable {}
extension Tendermint_Abci_ResponseApplySnapshotChunk: @unchecked Sendable {}
extension Tendermint_Abci_ResponseApplySnapshotChunk.Result: @unchecked Sendable {}
extension Tendermint_Abci_ResponsePrepareProposal: @unchecked Sendable {}
extension Tendermint_Abci_ResponseProcessProposal: @unchecked Sendable {}
extension Tendermint_Abci_ResponseProcessProposal.ProposalStatus: @unchecked Sendable {}
extension Tendermint_Abci_ResponseExtendVote: @unchecked Sendable {}
extension Tendermint_Abci_ResponseVerifyVoteExtension: @unchecked Sendable {}
extension Tendermint_Abci_ResponseVerifyVoteExtension.VerifyStatus: @unchecked Sendable {}
extension Tendermint_Abci_ResponseFinalizeBlock: @unchecked Sendable {}
extension Tendermint_Abci_CommitInfo: @unchecked Sendable {}
extension Tendermint_Abci_ExtendedCommitInfo: @unchecked Sendable {}
extension Tendermint_Abci_Event: @unchecked Sendable {}
extension Tendermint_Abci_EventAttribute: @unchecked Sendable {}
extension Tendermint_Abci_ExecTxResult: @unchecked Sendable {}
extension Tendermint_Abci_TxResult: @unchecked Sendable {}
extension Tendermint_Abci_Validator: @unchecked Sendable {}
extension Tendermint_Abci_ValidatorUpdate: @unchecked Sendable {}
extension Tendermint_Abci_VoteInfo: @unchecked Sendable {}
extension Tendermint_Abci_ExtendedVoteInfo: @unchecked Sendable {}
extension Tendermint_Abci_Misbehavior: @unchecked Sendable {}
extension Tendermint_Abci_Snapshot: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "tendermint.abci"

extension Tendermint_Abci_CheckTxType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NEW"),
    1: .same(proto: "RECHECK"),
  ]
}

extension Tendermint_Abci_MisbehaviorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "DUPLICATE_VOTE"),
    2: .same(proto: "LIGHT_CLIENT_ATTACK"),
  ]
}

extension Tendermint_Abci_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "echo"),
    2: .same(proto: "flush"),
    3: .same(proto: "info"),
    5: .standard(proto: "init_chain"),
    6: .same(proto: "query"),
    8: .standard(proto: "check_tx"),
    11: .same(proto: "commit"),
    12: .standard(proto: "list_snapshots"),
    13: .standard(proto: "offer_snapshot"),
    14: .standard(proto: "load_snapshot_chunk"),
    15: .standard(proto: "apply_snapshot_chunk"),
    16: .standard(proto: "prepare_proposal"),
    17: .standard(proto: "process_proposal"),
    18: .standard(proto: "extend_vote"),
    19: .standard(proto: "verify_vote_extension"),
    20: .standard(proto: "finalize_block"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Tendermint_Abci_RequestEcho?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .echo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .echo(v)
        }
      }()
      case 2: try {
        var v: Tendermint_Abci_RequestFlush?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .flush(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .flush(v)
        }
      }()
      case 3: try {
        var v: Tendermint_Abci_RequestInfo?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .info(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .info(v)
        }
      }()
      case 5: try {
        var v: Tendermint_Abci_RequestInitChain?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .initChain(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .initChain(v)
        }
      }()
      case 6: try {
        var v: Tendermint_Abci_RequestQuery?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .query(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .query(v)
        }
      }()
      case 8: try {
        var v: Tendermint_Abci_RequestCheckTx?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .checkTx(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .checkTx(v)
        }
      }()
      case 11: try {
        var v: Tendermint_Abci_RequestCommit?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .commit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .commit(v)
        }
      }()
      case 12: try {
        var v: Tendermint_Abci_RequestListSnapshots?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .listSnapshots(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .listSnapshots(v)
        }
      }()
      case 13: try {
        var v: Tendermint_Abci_RequestOfferSnapshot?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .offerSnapshot(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .offerSnapshot(v)
        }
      }()
      case 14: try {
        var v: Tendermint_Abci_RequestLoadSnapshotChunk?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .loadSnapshotChunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .loadSnapshotChunk(v)
        }
      }()
      case 15: try {
        var v: Tendermint_Abci_RequestApplySnapshotChunk?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .applySnapshotChunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .applySnapshotChunk(v)
        }
      }()
      case 16: try {
        var v: Tendermint_Abci_RequestPrepareProposal?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .prepareProposal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .prepareProposal(v)
        }
      }()
      case 17: try {
        var v: Tendermint_Abci_RequestProcessProposal?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .processProposal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .processProposal(v)
        }
      }()
      case 18: try {
        var v: Tendermint_Abci_RequestExtendVote?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .extendVote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .extendVote(v)
        }
      }()
      case 19: try {
        var v: Tendermint_Abci_RequestVerifyVoteExtension?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .verifyVoteExtension(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .verifyVoteExtension(v)
        }
      }()
      case 20: try {
        var v: Tendermint_Abci_RequestFinalizeBlock?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .finalizeBlock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .finalizeBlock(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .echo?: try {
      guard case .echo(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .flush?: try {
      guard case .flush(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .info?: try {
      guard case .info(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .initChain?: try {
      guard case .initChain(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .query?: try {
      guard case .query(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .checkTx?: try {
      guard case .checkTx(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .commit?: try {
      guard case .commit(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .listSnapshots?: try {
      guard case .listSnapshots(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .offerSnapshot?: try {
      guard case .offerSnapshot(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .loadSnapshotChunk?: try {
      guard case .loadSnapshotChunk(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .applySnapshotChunk?: try {
      guard case .applySnapshotChunk(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .prepareProposal?: try {
      guard case .prepareProposal(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .processProposal?: try {
      guard case .processProposal(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .extendVote?: try {
      guard case .extendVote(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .verifyVoteExtension?: try {
      guard case .verifyVoteExtension(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .finalizeBlock?: try {
      guard case .finalizeBlock(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_Request, rhs: Tendermint_Abci_Request) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestEcho: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestEcho"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestEcho, rhs: Tendermint_Abci_RequestEcho) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestFlush: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestFlush"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestFlush, rhs: Tendermint_Abci_RequestFlush) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "block_version"),
    3: .standard(proto: "p2p_version"),
    4: .standard(proto: "abci_version"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.blockVersion) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.p2PVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.abciVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    if self.blockVersion != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockVersion, fieldNumber: 2)
    }
    if self.p2PVersion != 0 {
      try visitor.visitSingularUInt64Field(value: self.p2PVersion, fieldNumber: 3)
    }
    if !self.abciVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.abciVersion, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestInfo, rhs: Tendermint_Abci_RequestInfo) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.blockVersion != rhs.blockVersion {return false}
    if lhs.p2PVersion != rhs.p2PVersion {return false}
    if lhs.abciVersion != rhs.abciVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestInitChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestInitChain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .standard(proto: "chain_id"),
    3: .standard(proto: "consensus_params"),
    4: .same(proto: "validators"),
    5: .standard(proto: "app_state_bytes"),
    6: .standard(proto: "initial_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._consensusParams) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.validators) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.appStateBytes) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.initialHeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 2)
    }
    try { if let v = self._consensusParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 4)
    }
    if !self.appStateBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.appStateBytes, fieldNumber: 5)
    }
    if self.initialHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.initialHeight, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestInitChain, rhs: Tendermint_Abci_RequestInitChain) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs.chainID != rhs.chainID {return false}
    if lhs._consensusParams != rhs._consensusParams {return false}
    if lhs.validators != rhs.validators {return false}
    if lhs.appStateBytes != rhs.appStateBytes {return false}
    if lhs.initialHeight != rhs.initialHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "path"),
    3: .same(proto: "height"),
    4: .same(proto: "prove"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.prove) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 3)
    }
    if self.prove != false {
      try visitor.visitSingularBoolField(value: self.prove, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestQuery, rhs: Tendermint_Abci_RequestQuery) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.path != rhs.path {return false}
    if lhs.height != rhs.height {return false}
    if lhs.prove != rhs.prove {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestCheckTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestCheckTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "tx"),
    2: .same(proto: "type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tx) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tx.isEmpty {
      try visitor.visitSingularBytesField(value: self.tx, fieldNumber: 1)
    }
    if self.type != .new {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestCheckTx, rhs: Tendermint_Abci_RequestCheckTx) -> Bool {
    if lhs.tx != rhs.tx {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestCommit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestCommit"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestCommit, rhs: Tendermint_Abci_RequestCommit) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestListSnapshots: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestListSnapshots"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestListSnapshots, rhs: Tendermint_Abci_RequestListSnapshots) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestOfferSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestOfferSnapshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "snapshot"),
    2: .standard(proto: "app_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._snapshot) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.appHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._snapshot {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.appHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.appHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestOfferSnapshot, rhs: Tendermint_Abci_RequestOfferSnapshot) -> Bool {
    if lhs._snapshot != rhs._snapshot {return false}
    if lhs.appHash != rhs.appHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestLoadSnapshotChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestLoadSnapshotChunk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "format"),
    3: .same(proto: "chunk"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.format) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.chunk) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    if self.format != 0 {
      try visitor.visitSingularUInt32Field(value: self.format, fieldNumber: 2)
    }
    if self.chunk != 0 {
      try visitor.visitSingularUInt32Field(value: self.chunk, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestLoadSnapshotChunk, rhs: Tendermint_Abci_RequestLoadSnapshotChunk) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.format != rhs.format {return false}
    if lhs.chunk != rhs.chunk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestApplySnapshotChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestApplySnapshotChunk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
    2: .same(proto: "chunk"),
    3: .same(proto: "sender"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.chunk) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 1)
    }
    if !self.chunk.isEmpty {
      try visitor.visitSingularBytesField(value: self.chunk, fieldNumber: 2)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestApplySnapshotChunk, rhs: Tendermint_Abci_RequestApplySnapshotChunk) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.chunk != rhs.chunk {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestPrepareProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestPrepareProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_tx_bytes"),
    2: .same(proto: "txs"),
    3: .standard(proto: "local_last_commit"),
    4: .same(proto: "misbehavior"),
    5: .same(proto: "height"),
    6: .same(proto: "time"),
    7: .standard(proto: "next_validators_hash"),
    8: .standard(proto: "proposer_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.maxTxBytes) }()
      case 2: try { try decoder.decodeRepeatedBytesField(value: &self.txs) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._localLastCommit) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.misbehavior) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.nextValidatorsHash) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.proposerAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.maxTxBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.maxTxBytes, fieldNumber: 1)
    }
    if !self.txs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.txs, fieldNumber: 2)
    }
    try { if let v = self._localLastCommit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.misbehavior.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.misbehavior, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 5)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.nextValidatorsHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextValidatorsHash, fieldNumber: 7)
    }
    if !self.proposerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.proposerAddress, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestPrepareProposal, rhs: Tendermint_Abci_RequestPrepareProposal) -> Bool {
    if lhs.maxTxBytes != rhs.maxTxBytes {return false}
    if lhs.txs != rhs.txs {return false}
    if lhs._localLastCommit != rhs._localLastCommit {return false}
    if lhs.misbehavior != rhs.misbehavior {return false}
    if lhs.height != rhs.height {return false}
    if lhs._time != rhs._time {return false}
    if lhs.nextValidatorsHash != rhs.nextValidatorsHash {return false}
    if lhs.proposerAddress != rhs.proposerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestProcessProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestProcessProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txs"),
    2: .standard(proto: "proposed_last_commit"),
    3: .same(proto: "misbehavior"),
    4: .same(proto: "hash"),
    5: .same(proto: "height"),
    6: .same(proto: "time"),
    7: .standard(proto: "next_validators_hash"),
    8: .standard(proto: "proposer_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.txs) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._proposedLastCommit) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.misbehavior) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.nextValidatorsHash) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.proposerAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.txs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.txs, fieldNumber: 1)
    }
    try { if let v = self._proposedLastCommit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.misbehavior.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.misbehavior, fieldNumber: 3)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 5)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.nextValidatorsHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextValidatorsHash, fieldNumber: 7)
    }
    if !self.proposerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.proposerAddress, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestProcessProposal, rhs: Tendermint_Abci_RequestProcessProposal) -> Bool {
    if lhs.txs != rhs.txs {return false}
    if lhs._proposedLastCommit != rhs._proposedLastCommit {return false}
    if lhs.misbehavior != rhs.misbehavior {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.height != rhs.height {return false}
    if lhs._time != rhs._time {return false}
    if lhs.nextValidatorsHash != rhs.nextValidatorsHash {return false}
    if lhs.proposerAddress != rhs.proposerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestExtendVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestExtendVote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestExtendVote, rhs: Tendermint_Abci_RequestExtendVote) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestVerifyVoteExtension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestVerifyVoteExtension"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "validator_address"),
    3: .same(proto: "height"),
    4: .standard(proto: "vote_extension"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.validatorAddress) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.voteExtension) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.validatorAddress, fieldNumber: 2)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 3)
    }
    if !self.voteExtension.isEmpty {
      try visitor.visitSingularBytesField(value: self.voteExtension, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestVerifyVoteExtension, rhs: Tendermint_Abci_RequestVerifyVoteExtension) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs.height != rhs.height {return false}
    if lhs.voteExtension != rhs.voteExtension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_RequestFinalizeBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestFinalizeBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txs"),
    2: .standard(proto: "decided_last_commit"),
    3: .same(proto: "misbehavior"),
    4: .same(proto: "hash"),
    5: .same(proto: "height"),
    6: .same(proto: "time"),
    7: .standard(proto: "next_validators_hash"),
    8: .standard(proto: "proposer_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.txs) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._decidedLastCommit) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.misbehavior) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.nextValidatorsHash) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.proposerAddress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.txs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.txs, fieldNumber: 1)
    }
    try { if let v = self._decidedLastCommit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.misbehavior.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.misbehavior, fieldNumber: 3)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 4)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 5)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.nextValidatorsHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextValidatorsHash, fieldNumber: 7)
    }
    if !self.proposerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.proposerAddress, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_RequestFinalizeBlock, rhs: Tendermint_Abci_RequestFinalizeBlock) -> Bool {
    if lhs.txs != rhs.txs {return false}
    if lhs._decidedLastCommit != rhs._decidedLastCommit {return false}
    if lhs.misbehavior != rhs.misbehavior {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.height != rhs.height {return false}
    if lhs._time != rhs._time {return false}
    if lhs.nextValidatorsHash != rhs.nextValidatorsHash {return false}
    if lhs.proposerAddress != rhs.proposerAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exception"),
    2: .same(proto: "echo"),
    3: .same(proto: "flush"),
    4: .same(proto: "info"),
    6: .standard(proto: "init_chain"),
    7: .same(proto: "query"),
    9: .standard(proto: "check_tx"),
    10: .standard(proto: "deliver_tx"),
    12: .same(proto: "commit"),
    13: .standard(proto: "list_snapshots"),
    14: .standard(proto: "offer_snapshot"),
    15: .standard(proto: "load_snapshot_chunk"),
    16: .standard(proto: "apply_snapshot_chunk"),
    17: .standard(proto: "prepare_proposal"),
    18: .standard(proto: "process_proposal"),
    19: .standard(proto: "extend_vote"),
    20: .standard(proto: "verify_vote_extension"),
    21: .standard(proto: "finalize_block"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Tendermint_Abci_ResponseException?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .exception(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .exception(v)
        }
      }()
      case 2: try {
        var v: Tendermint_Abci_ResponseEcho?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .echo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .echo(v)
        }
      }()
      case 3: try {
        var v: Tendermint_Abci_ResponseFlush?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .flush(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .flush(v)
        }
      }()
      case 4: try {
        var v: Tendermint_Abci_ResponseInfo?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .info(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .info(v)
        }
      }()
      case 6: try {
        var v: Tendermint_Abci_ResponseInitChain?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .initChain(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .initChain(v)
        }
      }()
      case 7: try {
        var v: Tendermint_Abci_ResponseQuery?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .query(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .query(v)
        }
      }()
      case 9: try {
        var v: Tendermint_Abci_ResponseCheckTx?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .checkTx(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .checkTx(v)
        }
      }()
      case 10: try {
        var v: Tendermint_Abci_ResponseDeliverTx?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .deliverTx(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .deliverTx(v)
        }
      }()
      case 12: try {
        var v: Tendermint_Abci_ResponseCommit?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .commit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .commit(v)
        }
      }()
      case 13: try {
        var v: Tendermint_Abci_ResponseListSnapshots?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .listSnapshots(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .listSnapshots(v)
        }
      }()
      case 14: try {
        var v: Tendermint_Abci_ResponseOfferSnapshot?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .offerSnapshot(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .offerSnapshot(v)
        }
      }()
      case 15: try {
        var v: Tendermint_Abci_ResponseLoadSnapshotChunk?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .loadSnapshotChunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .loadSnapshotChunk(v)
        }
      }()
      case 16: try {
        var v: Tendermint_Abci_ResponseApplySnapshotChunk?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .applySnapshotChunk(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .applySnapshotChunk(v)
        }
      }()
      case 17: try {
        var v: Tendermint_Abci_ResponsePrepareProposal?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .prepareProposal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .prepareProposal(v)
        }
      }()
      case 18: try {
        var v: Tendermint_Abci_ResponseProcessProposal?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .processProposal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .processProposal(v)
        }
      }()
      case 19: try {
        var v: Tendermint_Abci_ResponseExtendVote?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .extendVote(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .extendVote(v)
        }
      }()
      case 20: try {
        var v: Tendermint_Abci_ResponseVerifyVoteExtension?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .verifyVoteExtension(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .verifyVoteExtension(v)
        }
      }()
      case 21: try {
        var v: Tendermint_Abci_ResponseFinalizeBlock?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .finalizeBlock(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .finalizeBlock(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .exception?: try {
      guard case .exception(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .echo?: try {
      guard case .echo(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .flush?: try {
      guard case .flush(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .info?: try {
      guard case .info(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .initChain?: try {
      guard case .initChain(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .query?: try {
      guard case .query(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .checkTx?: try {
      guard case .checkTx(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .deliverTx?: try {
      guard case .deliverTx(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .commit?: try {
      guard case .commit(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .listSnapshots?: try {
      guard case .listSnapshots(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .offerSnapshot?: try {
      guard case .offerSnapshot(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .loadSnapshotChunk?: try {
      guard case .loadSnapshotChunk(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .applySnapshotChunk?: try {
      guard case .applySnapshotChunk(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .prepareProposal?: try {
      guard case .prepareProposal(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .processProposal?: try {
      guard case .processProposal(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .extendVote?: try {
      guard case .extendVote(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .verifyVoteExtension?: try {
      guard case .verifyVoteExtension(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .finalizeBlock?: try {
      guard case .finalizeBlock(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_Response, rhs: Tendermint_Abci_Response) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseException: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseException"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.error) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseException, rhs: Tendermint_Abci_ResponseException) -> Bool {
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseEcho: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseEcho"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseEcho, rhs: Tendermint_Abci_ResponseEcho) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseFlush: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseFlush"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseFlush, rhs: Tendermint_Abci_ResponseFlush) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
    2: .same(proto: "version"),
    3: .standard(proto: "app_version"),
    4: .standard(proto: "last_block_height"),
    5: .standard(proto: "last_block_app_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.data) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.appVersion) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.lastBlockHeight) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.lastBlockAppHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if self.appVersion != 0 {
      try visitor.visitSingularUInt64Field(value: self.appVersion, fieldNumber: 3)
    }
    if self.lastBlockHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.lastBlockHeight, fieldNumber: 4)
    }
    if !self.lastBlockAppHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.lastBlockAppHash, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseInfo, rhs: Tendermint_Abci_ResponseInfo) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.version != rhs.version {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.lastBlockHeight != rhs.lastBlockHeight {return false}
    if lhs.lastBlockAppHash != rhs.lastBlockAppHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseInitChain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseInitChain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "consensus_params"),
    2: .same(proto: "validators"),
    3: .standard(proto: "app_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._consensusParams) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.validators) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.appHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._consensusParams {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.validators.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validators, fieldNumber: 2)
    }
    if !self.appHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.appHash, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseInitChain, rhs: Tendermint_Abci_ResponseInitChain) -> Bool {
    if lhs._consensusParams != rhs._consensusParams {return false}
    if lhs.validators != rhs.validators {return false}
    if lhs.appHash != rhs.appHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseQuery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseQuery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    3: .same(proto: "log"),
    4: .same(proto: "info"),
    5: .same(proto: "index"),
    6: .same(proto: "key"),
    7: .same(proto: "value"),
    8: .standard(proto: "proof_ops"),
    9: .same(proto: "height"),
    10: .same(proto: "codespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.log) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.info) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.index) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._proofOps) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.codespace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.log.isEmpty {
      try visitor.visitSingularStringField(value: self.log, fieldNumber: 3)
    }
    if !self.info.isEmpty {
      try visitor.visitSingularStringField(value: self.info, fieldNumber: 4)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 5)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 6)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 7)
    }
    try { if let v = self._proofOps {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 9)
    }
    if !self.codespace.isEmpty {
      try visitor.visitSingularStringField(value: self.codespace, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseQuery, rhs: Tendermint_Abci_ResponseQuery) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.log != rhs.log {return false}
    if lhs.info != rhs.info {return false}
    if lhs.index != rhs.index {return false}
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs._proofOps != rhs._proofOps {return false}
    if lhs.height != rhs.height {return false}
    if lhs.codespace != rhs.codespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseCheckTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseCheckTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "data"),
    3: .same(proto: "log"),
    4: .same(proto: "info"),
    5: .same(proto: "gas_wanted"),
    6: .same(proto: "gas_used"),
    7: .same(proto: "events"),
    8: .same(proto: "codespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.log) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.info) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.gasWanted) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.gasUsed) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.codespace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.log.isEmpty {
      try visitor.visitSingularStringField(value: self.log, fieldNumber: 3)
    }
    if !self.info.isEmpty {
      try visitor.visitSingularStringField(value: self.info, fieldNumber: 4)
    }
    if self.gasWanted != 0 {
      try visitor.visitSingularInt64Field(value: self.gasWanted, fieldNumber: 5)
    }
    if self.gasUsed != 0 {
      try visitor.visitSingularInt64Field(value: self.gasUsed, fieldNumber: 6)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 7)
    }
    if !self.codespace.isEmpty {
      try visitor.visitSingularStringField(value: self.codespace, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseCheckTx, rhs: Tendermint_Abci_ResponseCheckTx) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.data != rhs.data {return false}
    if lhs.log != rhs.log {return false}
    if lhs.info != rhs.info {return false}
    if lhs.gasWanted != rhs.gasWanted {return false}
    if lhs.gasUsed != rhs.gasUsed {return false}
    if lhs.events != rhs.events {return false}
    if lhs.codespace != rhs.codespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseDeliverTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseDeliverTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "data"),
    3: .same(proto: "log"),
    4: .same(proto: "info"),
    5: .same(proto: "gas_wanted"),
    6: .same(proto: "gas_used"),
    7: .same(proto: "events"),
    8: .same(proto: "codespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.log) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.info) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.gasWanted) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.gasUsed) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.codespace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.log.isEmpty {
      try visitor.visitSingularStringField(value: self.log, fieldNumber: 3)
    }
    if !self.info.isEmpty {
      try visitor.visitSingularStringField(value: self.info, fieldNumber: 4)
    }
    if self.gasWanted != 0 {
      try visitor.visitSingularInt64Field(value: self.gasWanted, fieldNumber: 5)
    }
    if self.gasUsed != 0 {
      try visitor.visitSingularInt64Field(value: self.gasUsed, fieldNumber: 6)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 7)
    }
    if !self.codespace.isEmpty {
      try visitor.visitSingularStringField(value: self.codespace, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseDeliverTx, rhs: Tendermint_Abci_ResponseDeliverTx) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.data != rhs.data {return false}
    if lhs.log != rhs.log {return false}
    if lhs.info != rhs.info {return false}
    if lhs.gasWanted != rhs.gasWanted {return false}
    if lhs.gasUsed != rhs.gasUsed {return false}
    if lhs.events != rhs.events {return false}
    if lhs.codespace != rhs.codespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseCommit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseCommit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "retain_height"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.retainHeight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.retainHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.retainHeight, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseCommit, rhs: Tendermint_Abci_ResponseCommit) -> Bool {
    if lhs.retainHeight != rhs.retainHeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseListSnapshots: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseListSnapshots"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "snapshots"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.snapshots) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.snapshots.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.snapshots, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseListSnapshots, rhs: Tendermint_Abci_ResponseListSnapshots) -> Bool {
    if lhs.snapshots != rhs.snapshots {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseOfferSnapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseOfferSnapshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseOfferSnapshot, rhs: Tendermint_Abci_ResponseOfferSnapshot) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseOfferSnapshot.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ACCEPT"),
    2: .same(proto: "ABORT"),
    3: .same(proto: "REJECT"),
    4: .same(proto: "REJECT_FORMAT"),
    5: .same(proto: "REJECT_SENDER"),
  ]
}

extension Tendermint_Abci_ResponseLoadSnapshotChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseLoadSnapshotChunk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chunk"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.chunk) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chunk.isEmpty {
      try visitor.visitSingularBytesField(value: self.chunk, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseLoadSnapshotChunk, rhs: Tendermint_Abci_ResponseLoadSnapshotChunk) -> Bool {
    if lhs.chunk != rhs.chunk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseApplySnapshotChunk: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseApplySnapshotChunk"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "refetch_chunks"),
    3: .standard(proto: "reject_senders"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeRepeatedUInt32Field(value: &self.refetchChunks) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.rejectSenders) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.refetchChunks.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.refetchChunks, fieldNumber: 2)
    }
    if !self.rejectSenders.isEmpty {
      try visitor.visitRepeatedStringField(value: self.rejectSenders, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseApplySnapshotChunk, rhs: Tendermint_Abci_ResponseApplySnapshotChunk) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.refetchChunks != rhs.refetchChunks {return false}
    if lhs.rejectSenders != rhs.rejectSenders {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseApplySnapshotChunk.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ACCEPT"),
    2: .same(proto: "ABORT"),
    3: .same(proto: "RETRY"),
    4: .same(proto: "RETRY_SNAPSHOT"),
    5: .same(proto: "REJECT_SNAPSHOT"),
  ]
}

extension Tendermint_Abci_ResponsePrepareProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponsePrepareProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.txs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.txs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponsePrepareProposal, rhs: Tendermint_Abci_ResponsePrepareProposal) -> Bool {
    if lhs.txs != rhs.txs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseProcessProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseProcessProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseProcessProposal, rhs: Tendermint_Abci_ResponseProcessProposal) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseProcessProposal.ProposalStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ACCEPT"),
    2: .same(proto: "REJECT"),
  ]
}

extension Tendermint_Abci_ResponseExtendVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseExtendVote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vote_extension"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.voteExtension) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.voteExtension.isEmpty {
      try visitor.visitSingularBytesField(value: self.voteExtension, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseExtendVote, rhs: Tendermint_Abci_ResponseExtendVote) -> Bool {
    if lhs.voteExtension != rhs.voteExtension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseVerifyVoteExtension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseVerifyVoteExtension"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseVerifyVoteExtension, rhs: Tendermint_Abci_ResponseVerifyVoteExtension) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ResponseVerifyVoteExtension.VerifyStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "ACCEPT"),
    2: .same(proto: "REJECT"),
  ]
}

extension Tendermint_Abci_ResponseFinalizeBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResponseFinalizeBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "events"),
    2: .standard(proto: "tx_results"),
    3: .standard(proto: "validator_updates"),
    4: .standard(proto: "consensus_param_updates"),
    5: .standard(proto: "app_hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.txResults) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.validatorUpdates) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._consensusParamUpdates) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.appHash) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    if !self.txResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txResults, fieldNumber: 2)
    }
    if !self.validatorUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.validatorUpdates, fieldNumber: 3)
    }
    try { if let v = self._consensusParamUpdates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.appHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.appHash, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ResponseFinalizeBlock, rhs: Tendermint_Abci_ResponseFinalizeBlock) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.txResults != rhs.txResults {return false}
    if lhs.validatorUpdates != rhs.validatorUpdates {return false}
    if lhs._consensusParamUpdates != rhs._consensusParamUpdates {return false}
    if lhs.appHash != rhs.appHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_CommitInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "round"),
    2: .same(proto: "votes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.round) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.votes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.round != 0 {
      try visitor.visitSingularInt32Field(value: self.round, fieldNumber: 1)
    }
    if !self.votes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.votes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_CommitInfo, rhs: Tendermint_Abci_CommitInfo) -> Bool {
    if lhs.round != rhs.round {return false}
    if lhs.votes != rhs.votes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ExtendedCommitInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExtendedCommitInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "round"),
    2: .same(proto: "votes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.round) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.votes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.round != 0 {
      try visitor.visitSingularInt32Field(value: self.round, fieldNumber: 1)
    }
    if !self.votes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.votes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ExtendedCommitInfo, rhs: Tendermint_Abci_ExtendedCommitInfo) -> Bool {
    if lhs.round != rhs.round {return false}
    if lhs.votes != rhs.votes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "attributes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.attributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.attributes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_Event, rhs: Tendermint_Abci_Event) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_EventAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EventAttribute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
    3: .same(proto: "index"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if self.index != false {
      try visitor.visitSingularBoolField(value: self.index, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_EventAttribute, rhs: Tendermint_Abci_EventAttribute) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ExecTxResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecTxResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "data"),
    3: .same(proto: "log"),
    4: .same(proto: "info"),
    5: .standard(proto: "gas_wanted"),
    6: .standard(proto: "gas_used"),
    7: .same(proto: "events"),
    8: .same(proto: "codespace"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.log) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.info) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.gasWanted) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.gasUsed) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.codespace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.log.isEmpty {
      try visitor.visitSingularStringField(value: self.log, fieldNumber: 3)
    }
    if !self.info.isEmpty {
      try visitor.visitSingularStringField(value: self.info, fieldNumber: 4)
    }
    if self.gasWanted != 0 {
      try visitor.visitSingularInt64Field(value: self.gasWanted, fieldNumber: 5)
    }
    if self.gasUsed != 0 {
      try visitor.visitSingularInt64Field(value: self.gasUsed, fieldNumber: 6)
    }
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 7)
    }
    if !self.codespace.isEmpty {
      try visitor.visitSingularStringField(value: self.codespace, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ExecTxResult, rhs: Tendermint_Abci_ExecTxResult) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.data != rhs.data {return false}
    if lhs.log != rhs.log {return false}
    if lhs.info != rhs.info {return false}
    if lhs.gasWanted != rhs.gasWanted {return false}
    if lhs.gasUsed != rhs.gasUsed {return false}
    if lhs.events != rhs.events {return false}
    if lhs.codespace != rhs.codespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_TxResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "index"),
    3: .same(proto: "tx"),
    4: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.index) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.tx) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 1)
    }
    if self.index != 0 {
      try visitor.visitSingularUInt32Field(value: self.index, fieldNumber: 2)
    }
    if !self.tx.isEmpty {
      try visitor.visitSingularBytesField(value: self.tx, fieldNumber: 3)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_TxResult, rhs: Tendermint_Abci_TxResult) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.index != rhs.index {return false}
    if lhs.tx != rhs.tx {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_Validator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Validator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    3: .same(proto: "power"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.address) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.power) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if self.power != 0 {
      try visitor.visitSingularInt64Field(value: self.power, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_Validator, rhs: Tendermint_Abci_Validator) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.power != rhs.power {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ValidatorUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidatorUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .same(proto: "power"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pubKey) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.power) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pubKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.power != 0 {
      try visitor.visitSingularInt64Field(value: self.power, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ValidatorUpdate, rhs: Tendermint_Abci_ValidatorUpdate) -> Bool {
    if lhs._pubKey != rhs._pubKey {return false}
    if lhs.power != rhs.power {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_VoteInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VoteInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validator"),
    3: .standard(proto: "block_id_flag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._validator) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.blockIDFlag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._validator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.blockIDFlag != .unknown {
      try visitor.visitSingularEnumField(value: self.blockIDFlag, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_VoteInfo, rhs: Tendermint_Abci_VoteInfo) -> Bool {
    if lhs._validator != rhs._validator {return false}
    if lhs.blockIDFlag != rhs.blockIDFlag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_ExtendedVoteInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExtendedVoteInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validator"),
    3: .standard(proto: "vote_extension"),
    4: .standard(proto: "extension_signature"),
    5: .standard(proto: "block_id_flag"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._validator) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.voteExtension) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.extensionSignature) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.blockIDFlag) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._validator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.voteExtension.isEmpty {
      try visitor.visitSingularBytesField(value: self.voteExtension, fieldNumber: 3)
    }
    if !self.extensionSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.extensionSignature, fieldNumber: 4)
    }
    if self.blockIDFlag != .unknown {
      try visitor.visitSingularEnumField(value: self.blockIDFlag, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_ExtendedVoteInfo, rhs: Tendermint_Abci_ExtendedVoteInfo) -> Bool {
    if lhs._validator != rhs._validator {return false}
    if lhs.voteExtension != rhs.voteExtension {return false}
    if lhs.extensionSignature != rhs.extensionSignature {return false}
    if lhs.blockIDFlag != rhs.blockIDFlag {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_Misbehavior: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Misbehavior"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "validator"),
    3: .same(proto: "height"),
    4: .same(proto: "time"),
    5: .standard(proto: "total_voting_power"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._validator) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.totalVotingPower) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._validator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 3)
    }
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.totalVotingPower != 0 {
      try visitor.visitSingularInt64Field(value: self.totalVotingPower, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_Misbehavior, rhs: Tendermint_Abci_Misbehavior) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._validator != rhs._validator {return false}
    if lhs.height != rhs.height {return false}
    if lhs._time != rhs._time {return false}
    if lhs.totalVotingPower != rhs.totalVotingPower {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Tendermint_Abci_Snapshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Snapshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "height"),
    2: .same(proto: "format"),
    3: .same(proto: "chunks"),
    4: .same(proto: "hash"),
    5: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.height) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.format) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.chunks) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.height != 0 {
      try visitor.visitSingularUInt64Field(value: self.height, fieldNumber: 1)
    }
    if self.format != 0 {
      try visitor.visitSingularUInt32Field(value: self.format, fieldNumber: 2)
    }
    if self.chunks != 0 {
      try visitor.visitSingularUInt32Field(value: self.chunks, fieldNumber: 3)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 4)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularBytesField(value: self.metadata, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Tendermint_Abci_Snapshot, rhs: Tendermint_Abci_Snapshot) -> Bool {
    if lhs.height != rhs.height {return false}
    if lhs.format != rhs.format {return false}
    if lhs.chunks != rhs.chunks {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
