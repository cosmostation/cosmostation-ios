// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cosmos/group/v1/types.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// Since: cosmos-sdk 0.46

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// VoteOption enumerates the valid vote options for a given proposal.
enum Cosmos_Group_V1_VoteOption: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// VOTE_OPTION_UNSPECIFIED defines an unspecified vote option which will
  /// return an error.
  case unspecified // = 0

  /// VOTE_OPTION_YES defines a yes vote option.
  case yes // = 1

  /// VOTE_OPTION_ABSTAIN defines an abstain vote option.
  case abstain // = 2

  /// VOTE_OPTION_NO defines a no vote option.
  case no // = 3

  /// VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.
  case noWithVeto // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .yes
    case 2: self = .abstain
    case 3: self = .no
    case 4: self = .noWithVeto
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .yes: return 1
    case .abstain: return 2
    case .no: return 3
    case .noWithVeto: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Cosmos_Group_V1_VoteOption: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Cosmos_Group_V1_VoteOption] = [
    .unspecified,
    .yes,
    .abstain,
    .no,
    .noWithVeto,
  ]
}

#endif  // swift(>=4.2)

/// ProposalStatus defines proposal statuses.
enum Cosmos_Group_V1_ProposalStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// An empty value is invalid and not allowed.
  case unspecified // = 0

  /// Initial status of a proposal when submitted.
  case submitted // = 1

  /// Final status of a proposal when the final tally is done and the outcome
  /// passes the group policy's decision policy.
  case accepted // = 2

  /// Final status of a proposal when the final tally is done and the outcome
  /// is rejected by the group policy's decision policy.
  case rejected // = 3

  /// Final status of a proposal when the group policy is modified before the
  /// final tally.
  case aborted // = 4

  /// A proposal can be withdrawn before the voting start time by the owner.
  /// When this happens the final status is Withdrawn.
  case withdrawn // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .submitted
    case 2: self = .accepted
    case 3: self = .rejected
    case 4: self = .aborted
    case 5: self = .withdrawn
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .submitted: return 1
    case .accepted: return 2
    case .rejected: return 3
    case .aborted: return 4
    case .withdrawn: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Cosmos_Group_V1_ProposalStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Cosmos_Group_V1_ProposalStatus] = [
    .unspecified,
    .submitted,
    .accepted,
    .rejected,
    .aborted,
    .withdrawn,
  ]
}

#endif  // swift(>=4.2)

/// ProposalExecutorResult defines types of proposal executor results.
enum Cosmos_Group_V1_ProposalExecutorResult: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// An empty value is not allowed.
  case unspecified // = 0

  /// We have not yet run the executor.
  case notRun // = 1

  /// The executor was successful and proposed action updated state.
  case success // = 2

  /// The executor returned an error and proposed action didn't update state.
  case failure // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .notRun
    case 2: self = .success
    case 3: self = .failure
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .notRun: return 1
    case .success: return 2
    case .failure: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Cosmos_Group_V1_ProposalExecutorResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Cosmos_Group_V1_ProposalExecutorResult] = [
    .unspecified,
    .notRun,
    .success,
    .failure,
  ]
}

#endif  // swift(>=4.2)

/// Member represents a group member with an account address,
/// non-zero weight, metadata and added_at timestamp.
struct Cosmos_Group_V1_Member {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address is the member's account address.
  var address: String = String()

  /// weight is the member's voting weight that should be greater than 0.
  var weight: String = String()

  /// metadata is any arbitrary metadata attached to the member.
  var metadata: String = String()

  /// added_at is a timestamp specifying when a member was added.
  var addedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _addedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_addedAt = newValue}
  }
  /// Returns true if `addedAt` has been explicitly set.
  var hasAddedAt: Bool {return self._addedAt != nil}
  /// Clears the value of `addedAt`. Subsequent reads from it will return its default value.
  mutating func clearAddedAt() {self._addedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _addedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// MemberRequest represents a group member to be used in Msg server requests.
/// Contrary to `Member`, it doesn't have any `added_at` field
/// since this field cannot be set as part of requests.
struct Cosmos_Group_V1_MemberRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address is the member's account address.
  var address: String = String()

  /// weight is the member's voting weight that should be greater than 0.
  var weight: String = String()

  /// metadata is any arbitrary metadata attached to the member.
  var metadata: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ThresholdDecisionPolicy is a decision policy where a proposal passes when it
/// satisfies the two following conditions:
/// 1. The sum of all `YES` voter's weights is greater or equal than the defined
///    `threshold`.
/// 2. The voting and execution periods of the proposal respect the parameters
///    given by `windows`.
struct Cosmos_Group_V1_ThresholdDecisionPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// threshold is the minimum weighted sum of `YES` votes that must be met or
  /// exceeded for a proposal to succeed.
  var threshold: String = String()

  /// windows defines the different windows for voting and execution.
  var windows: Cosmos_Group_V1_DecisionPolicyWindows {
    get {return _windows ?? Cosmos_Group_V1_DecisionPolicyWindows()}
    set {_windows = newValue}
  }
  /// Returns true if `windows` has been explicitly set.
  var hasWindows: Bool {return self._windows != nil}
  /// Clears the value of `windows`. Subsequent reads from it will return its default value.
  mutating func clearWindows() {self._windows = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _windows: Cosmos_Group_V1_DecisionPolicyWindows? = nil
}

/// PercentageDecisionPolicy is a decision policy where a proposal passes when
/// it satisfies the two following conditions:
/// 1. The percentage of all `YES` voters' weights out of the total group weight
///    is greater or equal than the given `percentage`.
/// 2. The voting and execution periods of the proposal respect the parameters
///    given by `windows`.
struct Cosmos_Group_V1_PercentageDecisionPolicy {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// percentage is the minimum percentage of the weighted sum of `YES` votes must
  /// meet for a proposal to succeed.
  var percentage: String = String()

  /// windows defines the different windows for voting and execution.
  var windows: Cosmos_Group_V1_DecisionPolicyWindows {
    get {return _windows ?? Cosmos_Group_V1_DecisionPolicyWindows()}
    set {_windows = newValue}
  }
  /// Returns true if `windows` has been explicitly set.
  var hasWindows: Bool {return self._windows != nil}
  /// Clears the value of `windows`. Subsequent reads from it will return its default value.
  mutating func clearWindows() {self._windows = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _windows: Cosmos_Group_V1_DecisionPolicyWindows? = nil
}

/// DecisionPolicyWindows defines the different windows for voting and execution.
struct Cosmos_Group_V1_DecisionPolicyWindows {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// voting_period is the duration from submission of a proposal to the end of voting period
  /// Within this times votes can be submitted with MsgVote.
  var votingPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _votingPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_votingPeriod = newValue}
  }
  /// Returns true if `votingPeriod` has been explicitly set.
  var hasVotingPeriod: Bool {return self._votingPeriod != nil}
  /// Clears the value of `votingPeriod`. Subsequent reads from it will return its default value.
  mutating func clearVotingPeriod() {self._votingPeriod = nil}

  /// min_execution_period is the minimum duration after the proposal submission
  /// where members can start sending MsgExec. This means that the window for
  /// sending a MsgExec transaction is:
  /// `[ submission + min_execution_period ; submission + voting_period + max_execution_period]`
  /// where max_execution_period is a app-specific config, defined in the keeper.
  /// If not set, min_execution_period will default to 0.
  ///
  /// Please make sure to set a `min_execution_period` that is smaller than
  /// `voting_period + max_execution_period`, or else the above execution window
  /// is empty, meaning that all proposals created with this decision policy
  /// won't be able to be executed.
  var minExecutionPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _minExecutionPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_minExecutionPeriod = newValue}
  }
  /// Returns true if `minExecutionPeriod` has been explicitly set.
  var hasMinExecutionPeriod: Bool {return self._minExecutionPeriod != nil}
  /// Clears the value of `minExecutionPeriod`. Subsequent reads from it will return its default value.
  mutating func clearMinExecutionPeriod() {self._minExecutionPeriod = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _votingPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _minExecutionPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// GroupInfo represents the high-level on-chain information for a group.
struct Cosmos_Group_V1_GroupInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id is the unique ID of the group.
  var id: UInt64 = 0

  /// admin is the account address of the group's admin.
  var admin: String = String()

  /// metadata is any arbitrary metadata to attached to the group.
  var metadata: String = String()

  /// version is used to track changes to a group's membership structure that
  /// would break existing proposals. Whenever any members weight is changed,
  /// or any member is added or removed this version is incremented and will
  /// cause proposals based on older versions of this group to fail
  var version: UInt64 = 0

  /// total_weight is the sum of the group members' weights.
  var totalWeight: String = String()

  /// created_at is a timestamp specifying when a group was created.
  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// GroupMember represents the relationship between a group and a member.
struct Cosmos_Group_V1_GroupMember {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// group_id is the unique ID of the group.
  var groupID: UInt64 = 0

  /// member is the member data.
  var member: Cosmos_Group_V1_Member {
    get {return _member ?? Cosmos_Group_V1_Member()}
    set {_member = newValue}
  }
  /// Returns true if `member` has been explicitly set.
  var hasMember: Bool {return self._member != nil}
  /// Clears the value of `member`. Subsequent reads from it will return its default value.
  mutating func clearMember() {self._member = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _member: Cosmos_Group_V1_Member? = nil
}

/// GroupPolicyInfo represents the high-level on-chain information for a group policy.
struct Cosmos_Group_V1_GroupPolicyInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// address is the account address of group policy.
  var address: String = String()

  /// group_id is the unique ID of the group.
  var groupID: UInt64 = 0

  /// admin is the account address of the group admin.
  var admin: String = String()

  /// metadata is any arbitrary metadata attached to the group policy.
  /// the recommended format of the metadata is to be found here:
  /// https://docs.cosmos.network/v0.47/modules/group#decision-policy-1
  var metadata: String = String()

  /// version is used to track changes to a group's GroupPolicyInfo structure that
  /// would create a different result on a running proposal.
  var version: UInt64 = 0

  /// decision_policy specifies the group policy's decision policy.
  var decisionPolicy: SwiftProtobuf.Google_Protobuf_Any {
    get {return _decisionPolicy ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_decisionPolicy = newValue}
  }
  /// Returns true if `decisionPolicy` has been explicitly set.
  var hasDecisionPolicy: Bool {return self._decisionPolicy != nil}
  /// Clears the value of `decisionPolicy`. Subsequent reads from it will return its default value.
  mutating func clearDecisionPolicy() {self._decisionPolicy = nil}

  /// created_at is a timestamp specifying when a group policy was created.
  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _decisionPolicy: SwiftProtobuf.Google_Protobuf_Any? = nil
  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Proposal defines a group proposal. Any member of a group can submit a proposal
/// for a group policy to decide upon.
/// A proposal consists of a set of `sdk.Msg`s that will be executed if the proposal
/// passes as well as some optional metadata associated with the proposal.
struct Cosmos_Group_V1_Proposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id is the unique id of the proposal.
  var id: UInt64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// group_policy_address is the account address of group policy.
  var groupPolicyAddress: String {
    get {return _storage._groupPolicyAddress}
    set {_uniqueStorage()._groupPolicyAddress = newValue}
  }

  /// metadata is any arbitrary metadata attached to the proposal.
  /// the recommended format of the metadata is to be found here:
  /// https://docs.cosmos.network/v0.47/modules/group#proposal-4
  var metadata: String {
    get {return _storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  /// proposers are the account addresses of the proposers.
  var proposers: [String] {
    get {return _storage._proposers}
    set {_uniqueStorage()._proposers = newValue}
  }

  /// submit_time is a timestamp specifying when a proposal was submitted.
  var submitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._submitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._submitTime = newValue}
  }
  /// Returns true if `submitTime` has been explicitly set.
  var hasSubmitTime: Bool {return _storage._submitTime != nil}
  /// Clears the value of `submitTime`. Subsequent reads from it will return its default value.
  mutating func clearSubmitTime() {_uniqueStorage()._submitTime = nil}

  /// group_version tracks the version of the group at proposal submission.
  /// This field is here for informational purposes only.
  var groupVersion: UInt64 {
    get {return _storage._groupVersion}
    set {_uniqueStorage()._groupVersion = newValue}
  }

  /// group_policy_version tracks the version of the group policy at proposal submission.
  /// When a decision policy is changed, existing proposals from previous policy
  /// versions will become invalid with the `ABORTED` status.
  /// This field is here for informational purposes only.
  var groupPolicyVersion: UInt64 {
    get {return _storage._groupPolicyVersion}
    set {_uniqueStorage()._groupPolicyVersion = newValue}
  }

  /// status represents the high level position in the life cycle of the proposal. Initial value is Submitted.
  var status: Cosmos_Group_V1_ProposalStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// final_tally_result contains the sums of all weighted votes for this
  /// proposal for each vote option. It is empty at submission, and only
  /// populated after tallying, at voting period end or at proposal execution,
  /// whichever happens first.
  var finalTallyResult: Cosmos_Group_V1_TallyResult {
    get {return _storage._finalTallyResult ?? Cosmos_Group_V1_TallyResult()}
    set {_uniqueStorage()._finalTallyResult = newValue}
  }
  /// Returns true if `finalTallyResult` has been explicitly set.
  var hasFinalTallyResult: Bool {return _storage._finalTallyResult != nil}
  /// Clears the value of `finalTallyResult`. Subsequent reads from it will return its default value.
  mutating func clearFinalTallyResult() {_uniqueStorage()._finalTallyResult = nil}

  /// voting_period_end is the timestamp before which voting must be done.
  /// Unless a successful MsgExec is called before (to execute a proposal whose
  /// tally is successful before the voting period ends), tallying will be done
  /// at this point, and the `final_tally_result`and `status` fields will be
  /// accordingly updated.
  var votingPeriodEnd: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._votingPeriodEnd ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._votingPeriodEnd = newValue}
  }
  /// Returns true if `votingPeriodEnd` has been explicitly set.
  var hasVotingPeriodEnd: Bool {return _storage._votingPeriodEnd != nil}
  /// Clears the value of `votingPeriodEnd`. Subsequent reads from it will return its default value.
  mutating func clearVotingPeriodEnd() {_uniqueStorage()._votingPeriodEnd = nil}

  /// executor_result is the final result of the proposal execution. Initial value is NotRun.
  var executorResult: Cosmos_Group_V1_ProposalExecutorResult {
    get {return _storage._executorResult}
    set {_uniqueStorage()._executorResult = newValue}
  }

  /// messages is a list of `sdk.Msg`s that will be executed if the proposal passes.
  var messages: [SwiftProtobuf.Google_Protobuf_Any] {
    get {return _storage._messages}
    set {_uniqueStorage()._messages = newValue}
  }

  /// title is the title of the proposal
  ///
  /// Since: cosmos-sdk 0.47
  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  /// summary is a short summary of the proposal
  ///
  /// Since: cosmos-sdk 0.47
  var summary: String {
    get {return _storage._summary}
    set {_uniqueStorage()._summary = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// TallyResult represents the sum of weighted votes for each vote option.
struct Cosmos_Group_V1_TallyResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// yes_count is the weighted sum of yes votes.
  var yesCount: String = String()

  /// abstain_count is the weighted sum of abstainers.
  var abstainCount: String = String()

  /// no_count is the weighted sum of no votes.
  var noCount: String = String()

  /// no_with_veto_count is the weighted sum of veto.
  var noWithVetoCount: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Vote represents a vote for a proposal.
struct Cosmos_Group_V1_Vote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// proposal is the unique ID of the proposal.
  var proposalID: UInt64 = 0

  /// voter is the account address of the voter.
  var voter: String = String()

  /// option is the voter's choice on the proposal.
  var option: Cosmos_Group_V1_VoteOption = .unspecified

  /// metadata is any arbitrary metadata attached to the vote.
  var metadata: String = String()

  /// submit_time is the timestamp when the vote was submitted.
  var submitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _submitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_submitTime = newValue}
  }
  /// Returns true if `submitTime` has been explicitly set.
  var hasSubmitTime: Bool {return self._submitTime != nil}
  /// Clears the value of `submitTime`. Subsequent reads from it will return its default value.
  mutating func clearSubmitTime() {self._submitTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _submitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Cosmos_Group_V1_VoteOption: @unchecked Sendable {}
extension Cosmos_Group_V1_ProposalStatus: @unchecked Sendable {}
extension Cosmos_Group_V1_ProposalExecutorResult: @unchecked Sendable {}
extension Cosmos_Group_V1_Member: @unchecked Sendable {}
extension Cosmos_Group_V1_MemberRequest: @unchecked Sendable {}
extension Cosmos_Group_V1_ThresholdDecisionPolicy: @unchecked Sendable {}
extension Cosmos_Group_V1_PercentageDecisionPolicy: @unchecked Sendable {}
extension Cosmos_Group_V1_DecisionPolicyWindows: @unchecked Sendable {}
extension Cosmos_Group_V1_GroupInfo: @unchecked Sendable {}
extension Cosmos_Group_V1_GroupMember: @unchecked Sendable {}
extension Cosmos_Group_V1_GroupPolicyInfo: @unchecked Sendable {}
extension Cosmos_Group_V1_Proposal: @unchecked Sendable {}
extension Cosmos_Group_V1_TallyResult: @unchecked Sendable {}
extension Cosmos_Group_V1_Vote: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "cosmos.group.v1"

extension Cosmos_Group_V1_VoteOption: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOTE_OPTION_UNSPECIFIED"),
    1: .same(proto: "VOTE_OPTION_YES"),
    2: .same(proto: "VOTE_OPTION_ABSTAIN"),
    3: .same(proto: "VOTE_OPTION_NO"),
    4: .same(proto: "VOTE_OPTION_NO_WITH_VETO"),
  ]
}

extension Cosmos_Group_V1_ProposalStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROPOSAL_STATUS_UNSPECIFIED"),
    1: .same(proto: "PROPOSAL_STATUS_SUBMITTED"),
    2: .same(proto: "PROPOSAL_STATUS_ACCEPTED"),
    3: .same(proto: "PROPOSAL_STATUS_REJECTED"),
    4: .same(proto: "PROPOSAL_STATUS_ABORTED"),
    5: .same(proto: "PROPOSAL_STATUS_WITHDRAWN"),
  ]
}

extension Cosmos_Group_V1_ProposalExecutorResult: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROPOSAL_EXECUTOR_RESULT_UNSPECIFIED"),
    1: .same(proto: "PROPOSAL_EXECUTOR_RESULT_NOT_RUN"),
    2: .same(proto: "PROPOSAL_EXECUTOR_RESULT_SUCCESS"),
    3: .same(proto: "PROPOSAL_EXECUTOR_RESULT_FAILURE"),
  ]
}

extension Cosmos_Group_V1_Member: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Member"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "weight"),
    3: .same(proto: "metadata"),
    4: .standard(proto: "added_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.weight) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._addedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.weight.isEmpty {
      try visitor.visitSingularStringField(value: self.weight, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 3)
    }
    try { if let v = self._addedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1_Member, rhs: Cosmos_Group_V1_Member) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs._addedAt != rhs._addedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1_MemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MemberRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "weight"),
    3: .same(proto: "metadata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.weight) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.weight.isEmpty {
      try visitor.visitSingularStringField(value: self.weight, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1_MemberRequest, rhs: Cosmos_Group_V1_MemberRequest) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1_ThresholdDecisionPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ThresholdDecisionPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threshold"),
    2: .same(proto: "windows"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.threshold) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._windows) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.threshold.isEmpty {
      try visitor.visitSingularStringField(value: self.threshold, fieldNumber: 1)
    }
    try { if let v = self._windows {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1_ThresholdDecisionPolicy, rhs: Cosmos_Group_V1_ThresholdDecisionPolicy) -> Bool {
    if lhs.threshold != rhs.threshold {return false}
    if lhs._windows != rhs._windows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1_PercentageDecisionPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PercentageDecisionPolicy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "percentage"),
    2: .same(proto: "windows"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.percentage) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._windows) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.percentage.isEmpty {
      try visitor.visitSingularStringField(value: self.percentage, fieldNumber: 1)
    }
    try { if let v = self._windows {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1_PercentageDecisionPolicy, rhs: Cosmos_Group_V1_PercentageDecisionPolicy) -> Bool {
    if lhs.percentage != rhs.percentage {return false}
    if lhs._windows != rhs._windows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1_DecisionPolicyWindows: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DecisionPolicyWindows"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "voting_period"),
    2: .standard(proto: "min_execution_period"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._votingPeriod) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._minExecutionPeriod) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._votingPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._minExecutionPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1_DecisionPolicyWindows, rhs: Cosmos_Group_V1_DecisionPolicyWindows) -> Bool {
    if lhs._votingPeriod != rhs._votingPeriod {return false}
    if lhs._minExecutionPeriod != rhs._minExecutionPeriod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1_GroupInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "admin"),
    3: .same(proto: "metadata"),
    4: .same(proto: "version"),
    5: .standard(proto: "total_weight"),
    6: .standard(proto: "created_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.version) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.totalWeight) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularUInt64Field(value: self.id, fieldNumber: 1)
    }
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 2)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 3)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 4)
    }
    if !self.totalWeight.isEmpty {
      try visitor.visitSingularStringField(value: self.totalWeight, fieldNumber: 5)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1_GroupInfo, rhs: Cosmos_Group_V1_GroupInfo) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.admin != rhs.admin {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.version != rhs.version {return false}
    if lhs.totalWeight != rhs.totalWeight {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1_GroupMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupMember"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .same(proto: "member"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._member) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.groupID != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._member {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1_GroupMember, rhs: Cosmos_Group_V1_GroupMember) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._member != rhs._member {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1_GroupPolicyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupPolicyInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "group_id"),
    3: .same(proto: "admin"),
    4: .same(proto: "metadata"),
    5: .same(proto: "version"),
    6: .standard(proto: "decision_policy"),
    7: .standard(proto: "created_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.admin) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.version) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._decisionPolicy) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularUInt64Field(value: self.groupID, fieldNumber: 2)
    }
    if !self.admin.isEmpty {
      try visitor.visitSingularStringField(value: self.admin, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 4)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt64Field(value: self.version, fieldNumber: 5)
    }
    try { if let v = self._decisionPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1_GroupPolicyInfo, rhs: Cosmos_Group_V1_GroupPolicyInfo) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.admin != rhs.admin {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.version != rhs.version {return false}
    if lhs._decisionPolicy != rhs._decisionPolicy {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1_Proposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Proposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "group_policy_address"),
    3: .same(proto: "metadata"),
    4: .same(proto: "proposers"),
    5: .standard(proto: "submit_time"),
    6: .standard(proto: "group_version"),
    7: .standard(proto: "group_policy_version"),
    8: .same(proto: "status"),
    9: .standard(proto: "final_tally_result"),
    10: .standard(proto: "voting_period_end"),
    11: .standard(proto: "executor_result"),
    12: .same(proto: "messages"),
    13: .same(proto: "title"),
    14: .same(proto: "summary"),
  ]

  fileprivate class _StorageClass {
    var _id: UInt64 = 0
    var _groupPolicyAddress: String = String()
    var _metadata: String = String()
    var _proposers: [String] = []
    var _submitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _groupVersion: UInt64 = 0
    var _groupPolicyVersion: UInt64 = 0
    var _status: Cosmos_Group_V1_ProposalStatus = .unspecified
    var _finalTallyResult: Cosmos_Group_V1_TallyResult? = nil
    var _votingPeriodEnd: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _executorResult: Cosmos_Group_V1_ProposalExecutorResult = .unspecified
    var _messages: [SwiftProtobuf.Google_Protobuf_Any] = []
    var _title: String = String()
    var _summary: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _groupPolicyAddress = source._groupPolicyAddress
      _metadata = source._metadata
      _proposers = source._proposers
      _submitTime = source._submitTime
      _groupVersion = source._groupVersion
      _groupPolicyVersion = source._groupPolicyVersion
      _status = source._status
      _finalTallyResult = source._finalTallyResult
      _votingPeriodEnd = source._votingPeriodEnd
      _executorResult = source._executorResult
      _messages = source._messages
      _title = source._title
      _summary = source._summary
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt64Field(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._groupPolicyAddress) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._metadata) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._proposers) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._submitTime) }()
        case 6: try { try decoder.decodeSingularUInt64Field(value: &_storage._groupVersion) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._groupPolicyVersion) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._finalTallyResult) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._votingPeriodEnd) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._executorResult) }()
        case 12: try { try decoder.decodeRepeatedMessageField(value: &_storage._messages) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._summary) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._id != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._groupPolicyAddress.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupPolicyAddress, fieldNumber: 2)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitSingularStringField(value: _storage._metadata, fieldNumber: 3)
      }
      if !_storage._proposers.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._proposers, fieldNumber: 4)
      }
      try { if let v = _storage._submitTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._groupVersion != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._groupVersion, fieldNumber: 6)
      }
      if _storage._groupPolicyVersion != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._groupPolicyVersion, fieldNumber: 7)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 8)
      }
      try { if let v = _storage._finalTallyResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._votingPeriodEnd {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._executorResult != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._executorResult, fieldNumber: 11)
      }
      if !_storage._messages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._messages, fieldNumber: 12)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 13)
      }
      if !_storage._summary.isEmpty {
        try visitor.visitSingularStringField(value: _storage._summary, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1_Proposal, rhs: Cosmos_Group_V1_Proposal) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._groupPolicyAddress != rhs_storage._groupPolicyAddress {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._proposers != rhs_storage._proposers {return false}
        if _storage._submitTime != rhs_storage._submitTime {return false}
        if _storage._groupVersion != rhs_storage._groupVersion {return false}
        if _storage._groupPolicyVersion != rhs_storage._groupPolicyVersion {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._finalTallyResult != rhs_storage._finalTallyResult {return false}
        if _storage._votingPeriodEnd != rhs_storage._votingPeriodEnd {return false}
        if _storage._executorResult != rhs_storage._executorResult {return false}
        if _storage._messages != rhs_storage._messages {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._summary != rhs_storage._summary {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1_TallyResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TallyResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "yes_count"),
    2: .standard(proto: "abstain_count"),
    3: .standard(proto: "no_count"),
    4: .standard(proto: "no_with_veto_count"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.yesCount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.abstainCount) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.noCount) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.noWithVetoCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.yesCount.isEmpty {
      try visitor.visitSingularStringField(value: self.yesCount, fieldNumber: 1)
    }
    if !self.abstainCount.isEmpty {
      try visitor.visitSingularStringField(value: self.abstainCount, fieldNumber: 2)
    }
    if !self.noCount.isEmpty {
      try visitor.visitSingularStringField(value: self.noCount, fieldNumber: 3)
    }
    if !self.noWithVetoCount.isEmpty {
      try visitor.visitSingularStringField(value: self.noWithVetoCount, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1_TallyResult, rhs: Cosmos_Group_V1_TallyResult) -> Bool {
    if lhs.yesCount != rhs.yesCount {return false}
    if lhs.abstainCount != rhs.abstainCount {return false}
    if lhs.noCount != rhs.noCount {return false}
    if lhs.noWithVetoCount != rhs.noWithVetoCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Cosmos_Group_V1_Vote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Vote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "proposal_id"),
    2: .same(proto: "voter"),
    3: .same(proto: "option"),
    4: .same(proto: "metadata"),
    5: .standard(proto: "submit_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.proposalID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.voter) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.option) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._submitTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.proposalID != 0 {
      try visitor.visitSingularUInt64Field(value: self.proposalID, fieldNumber: 1)
    }
    if !self.voter.isEmpty {
      try visitor.visitSingularStringField(value: self.voter, fieldNumber: 2)
    }
    if self.option != .unspecified {
      try visitor.visitSingularEnumField(value: self.option, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 4)
    }
    try { if let v = self._submitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Cosmos_Group_V1_Vote, rhs: Cosmos_Group_V1_Vote) -> Bool {
    if lhs.proposalID != rhs.proposalID {return false}
    if lhs.voter != rhs.voter {return false}
    if lhs.option != rhs.option {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs._submitTime != rhs._submitTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
